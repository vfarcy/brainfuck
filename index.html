<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß† BrainJS: Interpr√©teur Brainfuck</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }
        h1, h2 {
            color: #333;
        }
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
        }
        .editor-wrapper {
            position: relative;
            width: 100%;
            margin-top: 8px;
            margin-bottom: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
            overflow: hidden;
            display: grid; /* Utiliser grid pour superposer les √©l√©ments */
        }
        .editor-wrapper textarea,
        .editor-wrapper pre {
            grid-area: 1 / 1 / 2 / 2; /* Placer les deux dans la m√™me cellule de la grille */
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
            tab-size: 2;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .editor-wrapper pre {
            pointer-events: none;
            background-color: #fff;
        }
        .editor-wrapper textarea { 
            z-index: 1;
            border: none;
            background-color: transparent;
            color: transparent;
            caret-color: #222;
            resize: vertical;
            -webkit-text-fill-color: transparent;
        }
        .editor-wrapper textarea:focus {
            outline: none;
        }
        .code-editor::selection {
            background-color: rgba(33, 150, 243, 0.35);
        }
        .bf-token {
            display: inline;
            color: #444;
        }
        .bf-comment {
            color: #bdbdbd;
        }
        .bf-move-right,
        .bf-move-left {
            color: #1565c0;
        }
        .bf-increment,
        .bf-decrement {
            color: #2e7d32;
        }
        .bf-output {
            color: #ef6c00;
        }
        .bf-input {
            color: #8e24aa;
        }
        .bf-loop-start,
        .bf-loop-end {
            color: #d81b60;
        }
        .bf-fork {
            color: #ff6b35;
            background: rgba(255, 107, 53, 0.15);
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        .bf-active {
            background-color: #ff9900;
            color: #fff !important;
            border-radius: 3px;
            padding: 0 2px;
        }
        button {
            padding: 10px 15px;
            margin-right: 10px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        #run-all { background-color: #4CAF50; color: white; }
        #run-all:hover:not(:disabled) { background-color: #45a049; }
        #step-btn { background-color: #2196F3; color: white; }
        #step-btn:hover:not(:disabled) { background-color: #0b7dda; }
        #reset-btn { background-color: #f44336; color: white; }
        #reset-btn:hover:not(:disabled) { background-color: #da190b; }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        /* --- Styles de Sortie et M√©moire --- */
        #output-view, #code-view {
            white-space: pre-wrap;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #fff;
            min-height: 50px;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
            overflow: auto;
        }
        #memory-view {
            max-width: 100%;
        }
        .memory-scroll-wrapper {
            width: 100%;
            max-width: 100%;
        }
        .memory-scroll {
            overflow-x: auto;
            overflow-y: hidden;
            padding-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
        }
        .memory-scroll::-webkit-scrollbar {
            height: 8px;
        }
        .memory-scroll::-webkit-scrollbar-thumb {
            background-color: rgba(0,0,0,0.25);
            border-radius: 4px;
        }
        .memory-scroll::-webkit-scrollbar-track {
            background-color: rgba(0,0,0,0.05);
        }
        .memory-scroll table {
            border-collapse: collapse;
            font-size: 14px;
            min-width: 500px;
            width: max-content;
        }
        .memory-scroll td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
            white-space: nowrap;
        }
        .memory-scroll-slider {
            width: 100%;
            margin-top: 6px;
            appearance: none;
            height: 6px;
            border-radius: 4px;
            background: #d0d0d0;
            cursor: pointer;
        }
        .memory-scroll-slider:focus {
            outline: 2px solid rgba(33, 150, 243, 0.4);
            outline-offset: 2px;
        }
        .memory-scroll-slider::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2196F3;
            border: none;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
        }
        .memory-scroll-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2196F3;
            border: none;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
        }
        .header-row td {
            font-weight: bold;
            background-color: #f0f0f0;
            color: #555;
        }
        .active-cell {
            background-color: #ff9900 !important;
            color: white;
            font-weight: bold;
            border-color: #cc7a00 !important;
        }
        .ellipsis-cell {
            font-weight: bold;
            color: #999;
        }
        
        /* Styles pour le multithreading */
        #thread-info {
            background: linear-gradient(135deg, #e3f2fd, #f0f8ff);
            border: 2px solid #4a90e2;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        #multi-thread-view {
            margin-top: 20px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 12px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        
        .thread-state {
            background: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            transition: all 0.3s ease;
        }
        
        .thread-state:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .thread-state.active {
            border-left: 5px solid #4caf50;
            background: #f8fff8;
        }
        
        .thread-state.halted {
            border-left: 5px solid #f44336;
            background: #fff8f8;
        }
        
        .thread-state.current {
            border: 2px solid #2196F3;
            background: #e3f2fd;
        }
        
        .thread-header {
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .thread-details {
            color: #666;
            line-height: 1.4;
        }
        
        .thread-memory {
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 8px;
        }
        
        .thread-memory-scroll {
            overflow-x: auto;
            max-width: 100%;
            margin-top: 5px;
        }
        
        .thread-memory table {
            border-collapse: collapse;
            font-size: 11px;
            min-width: 300px;
        }
        
        .thread-memory td {
            border: 1px solid #ddd;
            padding: 4px 6px;
            text-align: center;
            white-space: nowrap;
        }
        
        .thread-memory .header-row td {
            font-weight: bold;
            background-color: #f0f0f0;
            color: #555;
            font-size: 10px;
        }
        
        .thread-memory .active-cell {
            background-color: #ff9900 !important;
            color: white;
            font-weight: bold;
            border-color: #cc7a00 !important;
        }
        
        .thread-code {
            margin-top: 8px;
            padding: 6px;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 11px;
            max-height: 60px;
            overflow-y: auto;
        }
        
        #max-threads-control {
            margin: 10px 0;
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
        }
        
        .warning-text {
            color: #856404;
            font-size: 12px;
            margin-top: 5px;
        }
    </style>
</head>
<body>

    <h1>üß† BrainJS: Interpr√©teur Brainfuck</h1>

    <label for="bf-code">Entrez votre programme Brainfuck :</label>
    <div class="editor-wrapper">
        <pre id="code-highlight" aria-hidden="true"></pre>
        <textarea id="bf-code" class="code-editor" rows="10" cols="80">++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.

// Exemples avec fork (commande 'y'):
// Simple: ++y    (Parent: cell[0]=0, Enfant: cell[1]=1)
// Test: +++y>+++y>+++
// ‚ö†Ô∏è Danger: +[y+]  (Explosion de threads!)</textarea>
    </div>
    
    <p>
        <button id="run-all" aria-label="Ex√©cuter d'un coup">‚ñ∂ Ex√©cuter D'un Coup</button>
        <button id="step-btn" aria-label="Ex√©cuter pas √† pas">üë£ Step (Tous Threads)</button>
        <button id="step-single-btn" aria-label="Ex√©cuter pas √† pas thread unique" style="display: none;">üë§ Step (Thread Actuel)</button>
        <button id="reset-btn" aria-label="R√©initialiser">üîÑ R√©initialiser</button>
    </p>
    
    <!-- Contr√¥le pour la limite de threads -->
    <div id="max-threads-control">
        <label for="max-threads">üõ°Ô∏è Limite max de threads:</label>
        <input type="number" id="max-threads" value="100" min="1" max="1000" style="width: 80px;">
        <div class="warning-text">
            ‚ö†Ô∏è Attention: La commande 'y' peut cr√©er des explosions de threads (ex: "+[y+]")
        </div>
    </div>

    <hr>
    
    <!-- Section d'information des threads -->
    <div id="thread-info">
        <strong>üîó Thread Principal (T0)</strong> - Aucun fork d√©tect√©
    </div>
    
    <!-- Vue multi-thread (masqu√©e par d√©faut) -->
    <div id="multi-thread-view" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">üîÄ √âtat de Tous les Threads Actifs</h3>
            <button id="toggle-thread-details" style="padding: 5px 10px; font-size: 12px;">
                üëÅÔ∏è Vue D√©taill√©e
            </button>
        </div>
        <div id="threads-container">
            <!-- Les threads s'afficheront ici dynamiquement -->
        </div>
    </div>
    
    <h2>Donn√©es d'Entr√©e (Input)</h2>
    <textarea id="bf-input" rows="3" cols="80" placeholder="Entrez les donn√©es lues par la commande ',' (virgule) ici. Par exemple: 'Hello'"></textarea>

    <h2>Sortie (Output)</h2>
    <pre id="output-view">En attente d'ex√©cution...</pre>

    <hr>

    <h2>√âtat de l'Interpr√©teur</h2>
    <p>
        Pointeur d'Instruction (IP): <span id="ip-view">0</span>
        &nbsp;|&nbsp;
        Pointeur de Cellule (PTR): <span id="ptr-view">0</span>
    </p>

    <h3>Code en cours d'ex√©cution</h3>
    <pre id="code-view"></pre>

    <h3>M√©moire (Cellules autour du PTR)</h3>
    <div id="memory-view"></div>

    <script src="BrainfuckInterpreter.js"></script> 

    <script>
        let interpreter = null;

        // R√©f√©rences DOM
        const codeInput = document.getElementById('bf-code');
        const inputData = document.getElementById('bf-input');
        const outputView = document.getElementById('output-view');
        const ipView = document.getElementById('ip-view');
        const ptrView = document.getElementById('ptr-view');
        const memoryView = document.getElementById('memory-view');
        const codeView = document.getElementById('code-view');
        const codeHighlight = document.getElementById('code-highlight');
        const runAllBtn = document.getElementById('run-all');
        const stepBtn = document.getElementById('step-btn');
        const stepSingleBtn = document.getElementById('step-single-btn');
        const resetBtn = document.getElementById('reset-btn');

        const BF_TOKEN_CLASSES = {
            '>': 'bf-move-right',
            '<': 'bf-move-left',
            '+': 'bf-increment',
            '-': 'bf-decrement',
            '.': 'bf-output',
            ',': 'bf-input',
            '[': 'bf-loop-start',
            ']': 'bf-loop-end',
            'y': 'bf-fork'
        };

        function escapeHtml(text) {
            return text.replace(/[&<>"']/g, (char) => {
                switch (char) {
                    case '&': return '&amp;';
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '"': return '&quot;';
                    case "'": return '&#39;';
                    default: return char;
                }
            });
        }

        function buildHighlightedHtml(source, activeIndex = null) {
            if (!source) return '';
            let html = '';
            for (let i = 0; i < source.length; i++) {
                const char = source[i];
                if (char === '\n') {
                    html += '\n';
                    continue;
                }
                const classes = ['bf-token'];
                const tokenClass = BF_TOKEN_CLASSES[char] || 'bf-comment';
                classes.push(tokenClass);
                if (activeIndex !== null && i === activeIndex) {
                    classes.push('bf-active');
                }
                html += `<span class="${classes.join(' ')}">${escapeHtml(char)}</span>`;
            }
            return html;
        }

        function renderEditorHighlight(activeOriginalIndex = null) {
            codeHighlight.innerHTML = buildHighlightedHtml(codeInput.value, activeOriginalIndex);
            syncHighlightScroll();
        }

        function syncHighlightScroll() {
            codeHighlight.style.transform = `translate(${-codeInput.scrollLeft}px, ${-codeInput.scrollTop}px)`;
            // La transformation est plus fluide si elle est dans une frame d'animation
            requestAnimationFrame(() => {
                codeHighlight.style.transform = `translate(${-codeInput.scrollLeft}px, ${-codeInput.scrollTop}px)`;
            });
        }

        function setupMemoryScrollbar(wrapper) {
            if (!wrapper) return;

            const scrollContainer = wrapper.querySelector('.memory-scroll');
            const slider = wrapper.querySelector('.memory-scroll-slider');

            if (!scrollContainer || !slider) return;

            const updateSlider = () => {
                const overflow = scrollContainer.scrollWidth - scrollContainer.clientWidth;
                if (overflow > 0.5) {
                    slider.style.display = 'block';
                    slider.max = overflow;
                    slider.value = Math.min(scrollContainer.scrollLeft, overflow);
                } else {
                    slider.style.display = 'none';
                    slider.value = 0;
                    scrollContainer.scrollLeft = 0;
                }
            };

            slider.addEventListener('input', () => {
                scrollContainer.scrollLeft = Number(slider.value);
            });

            scrollContainer.addEventListener('scroll', () => {
                slider.value = scrollContainer.scrollLeft;
            });

            requestAnimationFrame(updateSlider);
        }

        codeInput.addEventListener('input', () => {
            renderEditorHighlight();
        });

        codeInput.addEventListener('scroll', () => {
            syncHighlightScroll();
        });
        
        window.addEventListener('resize', () => {
            syncHighlightScroll();
            if (interpreter) {
                updateUI();
            }
        });

        // Premi√®re coloration au chargement du script
        renderEditorHighlight();
        
        /**
         * Initialise ou r√©initialise l'interpr√©teur avec le code et les donn√©es d'entr√©e.
         */
        function initializeInterpreter() {
            try {
                // R√©initialiser le gestionnaire de threads
                BrainfuckInterpreter.resetThreadManager();
                
                // Passage du code et des donn√©es d'entr√©e
                interpreter = new BrainfuckInterpreter(codeInput.value, inputData.value); 
                updateUI();
                runAllBtn.disabled = false;
                stepBtn.disabled = false;
                outputView.textContent = "Programme r√©initialis√©.";
            } catch (error) {
                alert("Erreur de syntaxe Brainfuck: " + error.message);
                interpreter = null;
            }
        }

        /**
         * Formate la valeur d'une cellule m√©moire pour l'affichage.
         * Si la valeur correspond √† un caract√®re ASCII imprimable, l'affiche.
         * @param {number} value La valeur num√©rique de la cellule.
         * @returns {string} La valeur format√©e en HTML.
         */
        function formatMemoryCell(value) {
            const hexValue = '0x' + value.toString(16).toUpperCase().padStart(2, '0');

            // Les caract√®res imprimables ASCII sont g√©n√©ralement entre 32 (espace) et 126 (~)
            if (value >= 32 && value <= 126) {
                const char = escapeHtml(String.fromCharCode(value));
                return `${hexValue} <span style="color: #aaa; font-weight: bold;">'<span style="color: #0b7dda;">${char}</span>'</span>`;
            }
            // Pour les autres valeurs (non imprimables, null, etc.), on affiche juste le nombre.
            return hexValue;
        }

        /**
         * Met √† jour tous les √©l√©ments de l'interface utilisateur.
         */
        function updateUI() {
            if (!interpreter) return;

            const state = interpreter.getState();

            // 1. Mise √† jour des compteurs et sortie
            outputView.textContent = state.output;
            ipView.textContent = state.ip;
            ptrView.textContent = state.ptr;

            // 2. Visualisation du code et du Pointeur d'Instruction (IP)
            
            const activeInstructionIndex = state.code.length === 0
                ? null
                : (state.ip < state.code.length ? state.ip : state.code.length - 1);
            const activeOriginalIndex = (!state.codeMap || state.codeMap.length === 0)
                ? null
                : (state.ip < state.codeMap.length ? state.codeMap[state.ip] : state.codeMap[state.codeMap.length - 1]);

            codeView.innerHTML = buildHighlightedHtml(state.code, activeInstructionIndex);
            renderEditorHighlight(activeOriginalIndex);


            // 3. Visualisation de la m√©moire et du Pointeur de Cellule (PTR)
            let memDisplay = '<table>';
            const windowRadius = 7;
            const memoryLength = state.memoryFull.length;
            const start = Math.max(0, state.ptr - windowRadius);
            const end = Math.min(state.ptr + windowRadius + 1, memoryLength);

            // Ligne 1: Index (PTR)
            memDisplay += '<tr class="header-row">';
            if (start > 0) {
                memDisplay += '<td class="ellipsis-cell">‚Ä¶</td>';
            }
            for (let i = start; i < end; i++) {
                memDisplay += `<td>${i}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td class="ellipsis-cell">‚Ä¶</td>';
            }
            memDisplay += '</tr>';

            // Ligne 2: Valeurs (Contenu de la cellule)
            memDisplay += '<tr>';
            if (start > 0) {
                memDisplay += '<td class="ellipsis-cell">‚Ä¶</td>';
            }
            for (let i = start; i < end; i++) {
                const cellClass = i === state.ptr ? 'active-cell' : '';
                const cellContent = formatMemoryCell(state.memoryFull[i]);
                memDisplay += `<td class="${cellClass}">${cellContent}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td class="ellipsis-cell">‚Ä¶</td>';
            }
            memDisplay += '</tr>';
            memDisplay += '</table>';

            memoryView.innerHTML = `
                <div class="memory-scroll-wrapper">
                    <div class="memory-scroll" role="region" aria-label="Fen√™tre m√©moire d√©filable">${memDisplay}</div>
                    <input type="range" class="memory-scroll-slider" min="0" value="0" step="1" aria-label="D√©filement horizontal de la m√©moire">
                </div>
            `;

            const memoryWrapper = memoryView.querySelector('.memory-scroll-wrapper');
            setupMemoryScrollbar(memoryWrapper);

            // Centrer automatiquement la vue m√©moire sur la cellule active
            const activeCellElement = memoryWrapper.querySelector('.active-cell');
            const scrollContainer = memoryWrapper.querySelector('.memory-scroll');
            if (activeCellElement && scrollContainer) {
                const containerWidth = scrollContainer.offsetWidth;
                const cellLeft = activeCellElement.offsetLeft;
                const cellWidth = activeCellElement.offsetWidth;
                // Calcule la position de d√©filement pour centrer la cellule
                const scrollTarget = cellLeft - (containerWidth / 2) + (cellWidth / 2);
                scrollContainer.scrollLeft = scrollTarget;
            }

            // 4. Mise √† jour des informations de threading
            updateThreadInfo(state);
            
            // Nettoyer les threads termin√©s p√©riodiquement
            if (state.totalThreads > 1) {
                const cleaned = BrainfuckInterpreter.cleanupHaltedThreads();
                if (cleaned > 0) {
                    console.log(`üßπ Nettoyage: ${cleaned} threads termin√©s supprim√©s`);
                }
            }
            
            // 5. Afficher la vue multi-thread si n√©cessaire
            if (state.totalThreads > 1) {
                updateMultiThreadView();
                document.getElementById('multi-thread-view').style.display = 'block';
                
                // Afficher le bouton Step Single en mode multi-thread
                stepSingleBtn.style.display = 'inline-block';
                stepBtn.textContent = 'üë£ Step (Tous Threads)';
            } else {
                document.getElementById('multi-thread-view').style.display = 'none';
                
                // Masquer le bouton Step Single en mode single-thread
                stepSingleBtn.style.display = 'none';
                stepBtn.textContent = 'üë£ Ex√©cuter Pas √† Pas';
            }

            // 6. Gestion de la fin du programme
            if (state.halted) {
                runAllBtn.disabled = true;
                stepBtn.disabled = true;
                if (!outputView.textContent.includes("termin√©")) {
                    outputView.textContent += "\n\n--- Programme termin√© ---";
                }
            }
        }

        // Nouvelle fonction pour les informations de thread
        function updateThreadInfo(state) {
            const threadInfo = document.getElementById('thread-info');
            let infoHTML = `<strong>üîó Thread T${state.threadId}</strong>`;
            
            if (state.parentId !== null) {
                infoHTML += ` (Enfant de T${state.parentId})`;
            } else {
                infoHTML += ` (Principal)`;
            }
            
            // Calculer les threads r√©els
            const manager = BrainfuckInterpreter.threadManager;
            let activeCount = 0;
            let totalCount = 0;
            if (manager) {
                for (const [threadId, thread] of manager.threads) {
                    totalCount++;
                    if (!thread.halted) {
                        activeCount++;
                    }
                }
            } else {
                activeCount = totalCount = 1;
            }
            
            infoHTML += `<br><strong>Threads:</strong> ${activeCount} actifs`;
            if (totalCount > activeCount) {
                infoHTML += ` (${totalCount - activeCount} termin√©s)`;
            }
            
            if (state.children.length > 0) {
                infoHTML += `<br><strong>Enfants Cr√©√©s:</strong> [${state.children.map(id => `T${id}`).join(', ')}]`;
            }
            
            if (state.isForked) {
                infoHTML += `<br><span style="color: #ff6b35;">üîÄ Ce thread a √©t√© cr√©√© par fork</span>`;
            }
            
            threadInfo.innerHTML = infoHTML;
        }

        // Nouvelle fonction pour la vue multi-thread
        function updateMultiThreadView() {
            const allStates = BrainfuckInterpreter.getAllThreadStates();
            const container = document.getElementById('threads-container');
            
            container.innerHTML = '';
            
            allStates.forEach(state => {
                const threadDiv = document.createElement('div');
                const currentThreadId = interpreter ? interpreter.getState().threadId : 0;
                const isCurrentThread = state.threadId === currentThreadId;
                
                let className = 'thread-state ';
                if (isCurrentThread) {
                    className += 'current ';
                } else if (state.halted) {
                    className += 'halted ';
                } else {
                    className += 'active ';
                }
                threadDiv.className = className.trim();
                
                // En-t√™te du thread
                const headerHTML = `
                    <div class="thread-header">
                        <span>üîó Thread T${state.threadId} ${state.parentId !== null ? `(Parent: T${state.parentId})` : '(Principal)'} ${isCurrentThread ? 'üëë Actuel' : ''}</span>
                        <span>${state.halted ? 'üõë Arr√™t√©' : '‚ñ∂Ô∏è Actif'}</span>
                    </div>
                `;
                
                // Informations de base
                const detailsHTML = `
                    <div class="thread-details">
                        <strong>PTR:</strong> ${state.ptr} | 
                        <strong>IP:</strong> ${state.ip} | 
                        <strong>Cellule:</strong> ${state.memoryFull[state.ptr] || 0}<br>
                        <strong>Instruction:</strong> "${state.currentInstruction || 'FIN'}" | 
                        <strong>Sortie:</strong> "${escapeHtml(state.output.slice(-20))}${state.output.length > 20 ? '...' : ''}"<br>
                        ${state.children.length > 0 ? `<strong>Enfants:</strong> [${state.children.map(id => `T${id}`).join(', ')}]` : ''}
                    </div>
                `;
                
                // Contenu selon le mode d'affichage
                let contentHTML = headerHTML + detailsHTML;
                
                if (showDetailedThreadView) {
                    // Visualisation de la m√©moire (fen√™tre autour du PTR)
                    const memoryHTML = generateThreadMemoryView(state);
                    
                    // Code en cours d'ex√©cution avec mise en √©vidence
                    const codeHTML = generateThreadCodeView(state);
                    
                    contentHTML += memoryHTML + codeHTML;
                }
                
                threadDiv.innerHTML = contentHTML;
                container.appendChild(threadDiv);
            });
        }

        // G√©n√®re la vue m√©moire pour un thread
        function generateThreadMemoryView(state) {
            const windowRadius = 5; // Fen√™tre plus petite pour √©conomiser l'espace
            const memoryLength = state.memoryFull.length;
            const start = Math.max(0, state.ptr - windowRadius);
            const end = Math.min(state.ptr + windowRadius + 1, memoryLength);

            let memDisplay = '<div class="thread-memory"><strong>M√©moire:</strong><div class="thread-memory-scroll"><table>';
            
            // Ligne 1: Index (PTR)
            memDisplay += '<tr class="header-row">';
            if (start > 0) {
                memDisplay += '<td>‚Ä¶</td>';
            }
            for (let i = start; i < end; i++) {
                memDisplay += `<td>${i}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td>‚Ä¶</td>';
            }
            memDisplay += '</tr>';

            // Ligne 2: Valeurs
            memDisplay += '<tr>';
            if (start > 0) {
                memDisplay += '<td>‚Ä¶</td>';
            }
            for (let i = start; i < end; i++) {
                const cellClass = i === state.ptr ? 'active-cell' : '';
                const value = state.memoryFull[i];
                const hexValue = '0x' + value.toString(16).toUpperCase().padStart(2, '0');
                let cellContent = hexValue;
                
                // Ajouter le caract√®re ASCII si imprimable
                if (value >= 32 && value <= 126) {
                    const char = escapeHtml(String.fromCharCode(value));
                    cellContent += `<br>'${char}'`;
                }
                
                memDisplay += `<td class="${cellClass}">${cellContent}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td>‚Ä¶</td>';
            }
            memDisplay += '</tr>';
            memDisplay += '</table></div></div>';
            
            return memDisplay;
        }

        // G√©n√®re la vue code pour un thread
        function generateThreadCodeView(state) {
            if (!state.code || state.code.length === 0) {
                return '<div class="thread-code"><em>Aucun code</em></div>';
            }
            
            // Afficher une fen√™tre autour de l'IP actuel
            const windowRadius = 10;
            const start = Math.max(0, state.ip - windowRadius);
            const end = Math.min(state.ip + windowRadius + 1, state.code.length);
            
            let codeDisplay = '<div class="thread-code"><strong>Code (IP=' + state.ip + '):</strong><br>';
            
            if (start > 0) {
                codeDisplay += '‚Ä¶';
            }
            
            for (let i = start; i < end; i++) {
                const char = state.code[i];
                if (i === state.ip) {
                    // Instruction actuelle en surbrillance
                    codeDisplay += `<span style="background: #ff9900; color: white; padding: 1px 2px; border-radius: 2px;">${escapeHtml(char)}</span>`;
                } else {
                    // Coloration normale
                    const tokenClass = BF_TOKEN_CLASSES[char] || 'bf-comment';
                    codeDisplay += `<span class="${tokenClass}">${escapeHtml(char)}</span>`;
                }
            }
            
            if (end < state.code.length) {
                codeDisplay += '‚Ä¶';
            }
            
            codeDisplay += '</div>';
            return codeDisplay;
        }

        // --- Gestionnaires d'√©v√©nements ---

        runAllBtn.addEventListener('click', () => {
            // R√©initialiser s'il n'y a pas d'interpr√©teur ou si l'ex√©cution pr√©c√©dente est termin√©e
            if (!interpreter || interpreter.getState().halted) initializeInterpreter();
            if (interpreter) {
                try {
                    const state = interpreter.getState();
                    
                    if (state.totalThreads > 1) {
                        // Ex√©cution multi-thread
                        console.log('üöÄ D√©marrage ex√©cution multi-thread...');
                        const results = BrainfuckInterpreter.runAllThreads();
                        console.log('‚úÖ Ex√©cution termin√©e. R√©sultats:', results);
                        
                        // Afficher un r√©sum√©
                        const summary = results.map(r => 
                            `T${r.threadId}: "${r.output}"`
                        ).join('\n');
                        alert(`Ex√©cution multi-thread termin√©e!\n\nR√©sultats:\n${summary}`);
                    } else {
                        // Ex√©cution single-thread classique
                        interpreter.runAll();
                        console.log('‚úÖ Ex√©cution single-thread termin√©e');
                    }
                    
                    updateUI();
                } catch (error) {
                    alert(`‚ùå Erreur d'ex√©cution: ${error.message}`);
                    console.error(error);
                }
            }
        });

        stepBtn.addEventListener('click', () => {
            if (!interpreter || interpreter.getState().halted) initializeInterpreter(); 
            if (interpreter) {
                try {
                    const state = interpreter.getState();
                    
                    if (state.totalThreads > 1) {
                        // Mode multi-thread: ex√©cuter une √©tape pour chaque thread actif
                        const manager = BrainfuckInterpreter.threadManager;
                        let anyProgress = false;
                        const threadsToRemove = [];
                        
                        for (const [threadId, thread] of manager.threads) {
                            if (!thread.halted) {
                                const continued = thread.step();
                                if (continued) {
                                    anyProgress = true;
                                } else {
                                    // Thread termin√©
                                    thread.halted = true;
                                    threadsToRemove.push(threadId);
                                    console.log(`üõë Thread T${threadId} termin√©. Restants: ${manager.activeThreads - 1}`);
                                }
                            }
                        }
                        
                        // Nettoyer les threads termin√©s du gestionnaire
                        threadsToRemove.forEach(threadId => {
                            manager.threads.delete(threadId);
                            manager.activeThreads--;
                        });
                        
                        if (!anyProgress && manager.activeThreads === 0) {
                            console.log('Tous les threads sont termin√©s');
                        }
                    } else {
                        // Mode single-thread classique
                        interpreter.step();
                    }
                    
                    updateUI();
                } catch (error) {
                    alert(`‚ùå Erreur d'ex√©cution step: ${error.message}`);
                    console.error(error);
                }
            }
        });

        stepSingleBtn.addEventListener('click', () => {
            if (!interpreter) return;
            
            try {
                // Ex√©cuter une √©tape seulement pour le thread principal (ou actuel)
                const continued = interpreter.step();
                if (!continued) {
                    console.log(`üõë Thread T${interpreter.threadId} termin√©`);
                }
                updateUI();
            } catch (error) {
                alert(`‚ùå Erreur d'ex√©cution step single: ${error.message}`);
                console.error(error);
            }
        });

        resetBtn.addEventListener('click', () => {
            BrainfuckInterpreter.resetThreadManager();
            initializeInterpreter();
        });

        // Gestionnaire pour la limite de threads
        document.getElementById('max-threads').addEventListener('change', (e) => {
            const newLimit = parseInt(e.target.value);
            if (newLimit > 0) {
                BrainfuckInterpreter.setMaxThreads(newLimit);
                console.log(`Limite de threads mise √† jour: ${newLimit}`);
            }
        });

        // Variable pour contr√¥ler la vue d√©taill√©e des threads
        let showDetailedThreadView = true;
        
        // Gestionnaire pour le bouton de bascule de vue
        document.getElementById('toggle-thread-details').addEventListener('click', () => {
            showDetailedThreadView = !showDetailedThreadView;
            const button = document.getElementById('toggle-thread-details');
            button.textContent = showDetailedThreadView ? 'üëÅÔ∏è Vue Compacte' : 'üëÅÔ∏è Vue D√©taill√©e';
            
            // Mettre √† jour l'affichage imm√©diatement
            if (interpreter && interpreter.getState().totalThreads > 1) {
                updateMultiThreadView();
            }
        });

        // Initialisation apr√®s le chargement complet
        window.addEventListener('load', () => {
            if (typeof BrainfuckInterpreter === 'undefined') {
                alert("Erreur: Le fichier 'BrainfuckInterpreter.js' n'a pas √©t√© trouv√© ou charg√© correctement. V√©rifiez le chemin.");
            } else {
                // Initialiser le bouton de vue
                const toggleButton = document.getElementById('toggle-thread-details');
                toggleButton.textContent = showDetailedThreadView ? 'üëÅÔ∏è Vue Compacte' : 'üëÅÔ∏è Vue D√©taill√©e';
                
                initializeInterpreter();
            }
        });

    </script>
</body>
</html>
