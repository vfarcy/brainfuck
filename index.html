<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß† ForkBrain - Where Brainfuck meets Unix threading !</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }
        h1, h2 {
            color: #333;
        }
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
        }
        .editor-wrapper {
            position: relative;
            width: 100%;
            margin-top: 8px;
            margin-bottom: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
            overflow: hidden;
            display: grid; /* Utiliser grid pour superposer les √©l√©ments */
        }
        .editor-wrapper textarea,
        .editor-wrapper pre {
            grid-area: 1 / 1 / 2 / 2; /* Placer les deux dans la m√™me cellule de la grille */
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
            tab-size: 2;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .editor-wrapper pre {
            pointer-events: none;
            background-color: #fff;
        }
        .editor-wrapper textarea { 
            z-index: 1;
            border: none;
            background-color: transparent;
            color: transparent;
            caret-color: #222;
            resize: vertical;
            -webkit-text-fill-color: transparent;
        }
        .editor-wrapper textarea:focus {
            outline: none;
        }
        .code-editor::selection {
            background-color: rgba(33, 150, 243, 0.35);
        }
        .bf-token {
            display: inline;
            color: #444;
        }
        .bf-comment {
            color: #bdbdbd;
        }
        .bf-move-right,
        .bf-move-left {
            color: #1565c0;
        }
        .bf-increment,
        .bf-decrement {
            color: #2e7d32;
        }
        .bf-output {
            color: #ef6c00;
        }
        .bf-input {
            color: #8e24aa;
        }
        .bf-loop-start,
        .bf-loop-end {
            color: #d81b60;
        }
        .bf-fork {
            color: #ff6b35;
            font-weight: bold;
        }
        .bf-active {
            background-color: #ff9900;
            color: #fff !important;
            border-radius: 3px;
            padding: 0 2px;
        }
        button {
            padding: 10px 15px;
            margin-right: 10px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        #run-all { background-color: #4CAF50; color: white; }
        #run-all:hover:not(:disabled) { background-color: #45a049; }
        #step-btn { background-color: #2196F3; color: white; }
        #step-btn:hover:not(:disabled) { background-color: #0b7dda; }
        #reset-btn { background-color: #f44336; color: white; }
        #reset-btn:hover:not(:disabled) { background-color: #da190b; }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        /* --- Styles de Sortie et M√©moire --- */
        #output-view, #code-view {
            white-space: pre-wrap;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #fff;
            min-height: 50px;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
            overflow: auto;
        }
        #memory-view {
            max-width: 100%;
        }
        .memory-scroll-wrapper {
            width: 100%;
            max-width: 100%;
        }
        .memory-scroll {
            overflow-x: auto;
            overflow-y: hidden;
            padding-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
        }
        .memory-scroll::-webkit-scrollbar {
            height: 8px;
        }
        .memory-scroll::-webkit-scrollbar-thumb {
            background-color: rgba(0,0,0,0.25);
            border-radius: 4px;
        }
        .memory-scroll::-webkit-scrollbar-track {
            background-color: rgba(0,0,0,0.05);
        }
        .memory-scroll table {
            border-collapse: collapse;
            font-size: 14px;
            min-width: 500px;
            width: max-content;
        }
        .memory-scroll td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
            white-space: nowrap;
        }
        .memory-scroll-slider {
            width: 100%;
            margin-top: 6px;
            appearance: none;
            height: 6px;
            border-radius: 4px;
            background: #d0d0d0;
            cursor: pointer;
        }
        .memory-scroll-slider:focus {
            outline: 2px solid rgba(33, 150, 243, 0.4);
            outline-offset: 2px;
        }
        .memory-scroll-slider::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2196F3;
            border: none;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
        }
        .memory-scroll-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2196F3;
            border: none;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
        }
        .header-row td {
            font-weight: bold;
            background-color: #f0f0f0;
            color: #555;
        }
        .active-cell {
            background-color: #ff9900 !important;
            color: white;
            font-weight: bold;
            border-color: #cc7a00 !important;
        }
        .ellipsis-cell {
            font-weight: bold;
            color: #999;
        }
        
        /* Styles pour le multithreading */
        #thread-info {
            background: linear-gradient(135deg, #e3f2fd, #f0f8ff);
            border: 2px solid #4a90e2;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        #multi-thread-view {
            margin-top: 20px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 12px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        
        .thread-state {
            background: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            transition: all 0.3s ease;
        }
        
        .thread-state:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .thread-state.active {
            border-left: 5px solid #4caf50;
            background: #f8fff8;
        }
        
        .thread-state.halted {
            border-left: 5px solid #f44336;
            background: #fff8f8;
        }
        
        .thread-state.current {
            border: 2px solid #2196F3;
            background: #e3f2fd;
        }
        
        .thread-execution-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4caf50;
            animation: pulse 1s infinite;
        }
        
        .thread-execution-indicator.executing {
            background: #ff9900;
            animation: flash 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        @keyframes flash {
            0% { background: #ff9900; transform: scale(1); }
            50% { background: #ffeb3b; transform: scale(1.2); }
            100% { background: #ff9900; transform: scale(1); }
        }
        
        .thread-timeline {
            margin-top: 10px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .step-counter {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #2196F3;
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .thread-progress-bar {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .thread-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        .execution-log {
            max-height: 100px;
            overflow-y: auto;
            font-size: 10px;
            background: #fafafa;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            padding: 5px;
            margin-top: 5px;
        }
        
        .thread-header {
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .thread-details {
            color: #666;
            line-height: 1.4;
        }
        
        .thread-memory {
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 8px;
        }
        
        .thread-memory-scroll {
            overflow-x: auto;
            max-width: 100%;
            margin-top: 5px;
        }
        
        .thread-memory table {
            border-collapse: collapse;
            font-size: 11px;
            min-width: 300px;
        }
        
        .thread-memory td {
            border: 1px solid #ddd;
            padding: 4px 6px;
            text-align: center;
            white-space: nowrap;
        }
        
        .thread-memory .header-row td {
            font-weight: bold;
            background-color: #f0f0f0;
            color: #555;
            font-size: 10px;
        }
        
        .thread-memory .active-cell {
            background-color: #ff9900 !important;
            color: white;
            font-weight: bold;
            border-color: #cc7a00 !important;
        }
        
        .thread-code {
            margin-top: 8px;
            padding: 6px;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 11px;
            max-height: 60px;
            overflow-y: auto;
        }
        
        #max-threads-control {
            margin: 10px 0;
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
        }
        
        .warning-text {
            color: #856404;
            font-size: 12px;
            margin-top: 5px;
        }
            /* Logs d'ex√©cution */
        .execution-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #2196F3;
        }

        .thread-logs {
            margin-top: 15px;
        }

        .thread-log-item {
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            background: #fff;
        }

        .thread-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .thread-id {
            font-weight: bold;
            color: #333;
        }

        .thread-steps {
            font-size: 0.9em;
            color: #666;
        }

        .thread-progress-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }

        .thread-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #2196F3);
            transition: width 0.3s ease;
        }

        /* Styles pour les zones d'entr√©e/sortie par thread */
        .thread-io {
            margin-top: 10px;
            padding: 8px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        
        .thread-io-section {
            margin-bottom: 8px;
        }
        
        .thread-io-label {
            font-weight: bold;
            font-size: 11px;
            color: #555;
            margin-bottom: 3px;
            display: block;
        }
        
        .thread-input {
            width: 100%;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-family: monospace;
            font-size: 11px;
            resize: none;
            height: 40px;
            box-sizing: border-box;
        }
        
        .thread-output {
            width: 100%;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-family: monospace;
            font-size: 11px;
            background: #fff;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 60px;
            overflow-y: auto;
            min-height: 40px;
            box-sizing: border-box;
        }
        
        .thread-output:empty:before {
            content: "Aucune sortie...";
            color: #999;
            font-style: italic;
        }
        
        .thread-io-compact {
            display: flex;
            gap: 10px;
        }
        
        .thread-io-compact .thread-io-section {
            flex: 1;
            margin-bottom: 0;
        }

        /* Styles pour les zones d'entr√©e par thread en mode multi-thread */
        .multi-thread-input {
            margin-bottom: 10px;
            padding: 8px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        
        .multi-thread-input-label {
            font-weight: bold;
            font-size: 12px;
            color: #555;
            margin-bottom: 5px;
            display: block;
        }
        
        .multi-thread-input textarea {
            width: 100%;
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
            height: 50px;
            box-sizing: border-box;
        }

        /* Couleurs pour identifier les threads dans la sortie */
        #output-view .thread-output-T0 { color: #2196F3 !important; font-weight: bold !important; }
        #output-view .thread-output-T1 { color: #4CAF50 !important; font-weight: bold !important; }
        #output-view .thread-output-T2 { color: #FF9800 !important; font-weight: bold !important; }
        #output-view .thread-output-T3 { color: #9C27B0 !important; font-weight: bold !important; }
        #output-view .thread-output-T4 { color: #F44336 !important; font-weight: bold !important; }
        #output-view .thread-output-T5 { color: #795548 !important; font-weight: bold !important; }
        #output-view .thread-output-T6 { color: #607D8B !important; font-weight: bold !important; }
        #output-view .thread-output-T7 { color: #E91E63 !important; font-weight: bold !important; }
        
        /* Style pour les caract√®res non-imprimables en hexa */
        .hex-char {
            background: #f0f0f0;
            padding: 1px 3px;
            border-radius: 2px;
            font-size: 0.9em;
            color: #666;
            font-family: 'Courier New', monospace;
            border: 1px solid #ddd;
            margin: 0 1px;
        }
        
        .hex-char:hover {
            background: #e0e0e0;
            border-color: #bbb;
        }
        
        /* Couleurs des threads pour les caract√®res hexad√©cimaux */
        #output-view .thread-output-T0 .hex-char { border-color: #2196F3 !important; background: #e3f2fd !important; color: #1565c0 !important; }
        #output-view .thread-output-T1 .hex-char { border-color: #4CAF50 !important; background: #e8f5e8 !important; color: #2e7d32 !important; }
        #output-view .thread-output-T2 .hex-char { border-color: #FF9800 !important; background: #fff3e0 !important; color: #ef6c00 !important; }
        #output-view .thread-output-T3 .hex-char { border-color: #9C27B0 !important; background: #f3e5f5 !important; color: #7b1fa2 !important; }
        #output-view .thread-output-T4 .hex-char { border-color: #F44336 !important; background: #ffebee !important; color: #d32f2f !important; }
        #output-view .thread-output-T5 .hex-char { border-color: #795548 !important; background: #efebe9 !important; color: #5d4037 !important; }
        #output-view .thread-output-T6 .hex-char { border-color: #607D8B !important; background: #eceff1 !important; color: #455a64 !important; }
        #output-view .thread-output-T7 .hex-char { border-color: #E91E63 !important; background: #fce4ec !important; color: #c2185b !important; }
        
        /* Effet hover pour les hex-char color√©s */
        .thread-output-T0 .hex-char:hover { background: #bbdefb; }
        .thread-output-T1 .hex-char:hover { background: #c8e6c9; }
        .thread-output-T2 .hex-char:hover { background: #ffe0b2; }
        .thread-output-T3 .hex-char:hover { background: #e1bee7; }
        .thread-output-T4 .hex-char:hover { background: #ffcdd2; }
        .thread-output-T5 .hex-char:hover { background: #d7ccc8; }
        .thread-output-T6 .hex-char:hover { background: #cfd8dc; }
        .thread-output-T7 .hex-char:hover { background: #f8bbd9; }
        
        /* Styles pour les caract√®res texte color√©s par thread */
        .thread-char-T0 { color: #2196F3; font-weight: bold; }
        .thread-char-T1 { color: #4CAF50; font-weight: bold; }
        .thread-char-T2 { color: #FF9800; font-weight: bold; }
        .thread-char-T3 { color: #9C27B0; font-weight: bold; }
        .thread-char-T4 { color: #F44336; font-weight: bold; }
        .thread-char-T5 { color: #795548; font-weight: bold; }
        .thread-char-T6 { color: #607D8B; font-weight: bold; }
        .thread-char-T7 { color: #E91E63; font-weight: bold; }
        
        /* Styles pour les caract√®res hexad√©cimaux color√©s par thread */
        .thread-hex-T0 { border-color: #2196F3; background: #e3f2fd; color: #1565c0; }
        .thread-hex-T1 { border-color: #4CAF50; background: #e8f5e8; color: #2e7d32; }
        .thread-hex-T2 { border-color: #FF9800; background: #fff3e0; color: #ef6c00; }
        .thread-hex-T3 { border-color: #9C27B0; background: #f3e5f5; color: #7b1fa2; }
        .thread-hex-T4 { border-color: #F44336; background: #ffebee; color: #d32f2f; }
        .thread-hex-T5 { border-color: #795548; background: #efebe9; color: #5d4037; }
        .thread-hex-T6 { border-color: #607D8B; background: #eceff1; color: #455a64; }
        .thread-hex-T7 { border-color: #E91E63; background: #fce4ec; color: #c2185b; }
        
        /* L√©gende des couleurs de threads */
        .thread-legend-item {
            display: inline-block;
            margin-right: 15px;
            font-size: 12px;
        }
        
        .thread-legend-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 5px;
            vertical-align: middle;
        }

        </style>
</head>
<body>

    <h1>üß† ForkBrain - Where Brainfuck meets Unix threading !</h1>

    <label for="bf-code">Entrez votre programme Brainfuck :</label>
    <div class="editor-wrapper">
        <pre id="code-highlight" aria-hidden="true"></pre>
        <textarea id="bf-code" class="code-editor" rows="10" cols="80">++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.

// Exemples avec fork (commande 'f'):
// Simple: ++f    (Parent: cell[0]=0, Enfant: cell[1]=1)
// Test: +++f>+++f>+++
// ‚ö†Ô∏è Danger: +[f+]  (Explosion de threads!)</textarea>
    </div>
    
    <p>
        <button id="run-all" aria-label="Ex√©cuter d'un coup">‚ñ∂ Ex√©cuter D'un Coup</button>
        <button id="step-btn" aria-label="Ex√©cuter pas √† pas">üë£ Step (Tous Threads)</button>
        <button id="step-single-btn" aria-label="Ex√©cuter pas √† pas thread unique" style="display: none;">üë§ Step (Thread Actuel)</button>
        <button id="switch-thread-btn" aria-label="Changer de thread actuel" style="display: none;">üîÑ Changer Thread</button>
        <button id="reset-btn" aria-label="R√©initialiser">üîÑ R√©initialiser</button>
    </p>
    
    <!-- Contr√¥le pour la limite de threads -->
    <div id="max-threads-control">
        <label for="max-threads">üõ°Ô∏è Limite max de threads:</label>
        <input type="number" id="max-threads" value="8" min="1" max="1000" style="width: 80px;">
        <div class="warning-text">
            ‚ö†Ô∏è Attention: La commande 'f' peut cr√©er des explosions de threads (ex: "+[f+]"). Limite globale de s√©curit√©.
        </div>
    </div>
    
    <!-- Compteur d'√©tapes global -->
    <div id="step-counter" class="step-counter" style="display: none;">
        √âtape: <span id="step-number">0</span>
    </div>

    <hr>
    
    <!-- Section d'information des threads -->
    <div id="thread-info">
        <strong>üîó Thread Principal (T0)</strong> - Aucun fork d√©tect√©
    </div>
    
    <!-- Vue multi-thread (masqu√©e par d√©faut) -->
    <div id="multi-thread-view" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">üîÄ √âtat de Tous les Threads Actifs</h3>
            <button id="toggle-thread-details" style="padding: 5px 10px; font-size: 12px;">
                üëÅÔ∏è Vue D√©taill√©e
            </button>
        </div>
        <div id="threads-container">
            <!-- Les threads s'afficheront ici dynamiquement -->
        </div>
    </div>
    
    <!-- Historique d'ex√©cution -->
    <div id="execution-log" style="margin-top: 20px; border: 2px solid #ddd; padding: 15px; background-color: #f9f9f9;">
        <h4>üìä Historique d'ex√©cution</h4>
        <p style="color: #666; font-style: italic;">Aucune ex√©cution pour le moment - Lancez un programme pour voir les statistiques !</p>
    </div>
    
    <!-- Zones d'entr√©e/sortie globales -->
    <div id="global-io">
        <h2>üì• Donn√©es d'Entr√©e (Input)</h2>
        <div id="input-section">
            <!-- Zone d'entr√©e globale pour le mode single-thread -->
            <div id="single-thread-input" style="display: block;">
                <textarea id="bf-input" rows="3" cols="80" placeholder="Entrez les donn√©es lues par la commande ',' (virgule) ici. Par exemple: 'Hello'"></textarea>
            </div>
            
            <!-- Zones d'entr√©e par thread pour le mode multi-thread -->
            <div id="multi-thread-inputs" style="display: none;">
                <!-- Les zones d'entr√©e par thread s'afficheront ici -->
            </div>
        </div>

        <h2>üì§ Sortie (Output) - Globale Unifi√©e</h2>
        <pre id="output-view">En attente d'ex√©cution...</pre>
        
        <!-- L√©gende des threads dans la sortie (visible uniquement en mode multi-thread) -->
        <div id="output-legend" style="display: none; margin-top: 10px; padding: 8px; background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 4px;">
            <strong>üè∑Ô∏è L√©gende des Threads:</strong>
            <div id="thread-colors-legend"></div>
        </div>
    </div>

    <hr>

    <!-- √âtat de l'interpr√©teur (visible uniquement en mode single-thread) -->
    <div id="single-thread-state">
        <h2>√âtat de l'Interpr√©teur</h2>
        <p>
            Pointeur d'Instruction (IP): <span id="ip-view">0</span>
            &nbsp;|&nbsp;
            Pointeur de Cellule (PTR): <span id="ptr-view">0</span>
        </p>

        <h3>Code en cours d'ex√©cution</h3>
        <pre id="code-view"></pre>

        <h3>M√©moire (Cellules autour du PTR)</h3>
        <div id="memory-view"></div>
    </div>

    <script src="BrainfuckInterpreter.js?v=1.12.0"></script> 

    <script>
        // V√©rification du chargement de BrainfuckInterpreter
        if (typeof BrainfuckInterpreter === 'undefined') {
            console.error('‚ùå BrainfuckInterpreter non charg√© !');
            alert('Erreur: Le fichier BrainfuckInterpreter.js n\'a pas pu √™tre charg√©. V√©rifiez votre connexion internet ou rechargez la page.');
        } else {
            console.log('‚úÖ BrainfuckInterpreter charg√© avec succ√®s');
            
            // L'interpr√©teur est correctement charg√©
            console.log('‚úÖ BrainfuckInterpreter charg√© avec succ√®s - Toutes les fonctionnalit√©s disponibles');
        }

        let interpreter = null;
        
        // Cache des sorties des threads pour la coloration
        let threadOutputsCache = new Map();

        // R√©f√©rences DOM
        const codeInput = document.getElementById('bf-code');
        const inputData = document.getElementById('bf-input');
        const outputView = document.getElementById('output-view');
        const ipView = document.getElementById('ip-view');
        const ptrView = document.getElementById('ptr-view');
        const memoryView = document.getElementById('memory-view');
        const codeView = document.getElementById('code-view');
        const codeHighlight = document.getElementById('code-highlight');
        const runAllBtn = document.getElementById('run-all');
        const stepBtn = document.getElementById('step-btn');
        const stepSingleBtn = document.getElementById('step-single-btn');
        const switchThreadBtn = document.getElementById('switch-thread-btn');
        const resetBtn = document.getElementById('reset-btn');

        const BF_TOKEN_CLASSES = {
            '>': 'bf-move-right',
            '<': 'bf-move-left',
            '+': 'bf-increment',
            '-': 'bf-decrement',
            '.': 'bf-output',
            ',': 'bf-input',
            '[': 'bf-loop-start',
            ']': 'bf-loop-end',
            'f': 'bf-fork'
        };

        function escapeHtml(text) {
            return text.replace(/[&<>"']/g, (char) => {
                switch (char) {
                    case '&': return '&amp;';
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '"': return '&quot;';
                    case "'": return '&#39;';
                    default: return char;
                }
            });
        }

        function buildHighlightedHtml(source, activeIndex = null) {
            if (!source) return '';
            let html = '';
            for (let i = 0; i < source.length; i++) {
                const char = source[i];
                if (char === '\n') {
                    html += '\n';
                    continue;
                }
                const classes = ['bf-token'];
                const tokenClass = BF_TOKEN_CLASSES[char] || 'bf-comment';
                classes.push(tokenClass);
                if (activeIndex !== null && i === activeIndex) {
                    classes.push('bf-active');
                }
                html += `<span class="${classes.join(' ')}">${escapeHtml(char)}</span>`;
            }
            return html;
        }

        function renderEditorHighlight(activeOriginalIndex = null) {
            codeHighlight.innerHTML = buildHighlightedHtml(codeInput.value, activeOriginalIndex);
            syncHighlightScroll();
        }

        function syncHighlightScroll() {
            codeHighlight.style.transform = `translate(${-codeInput.scrollLeft}px, ${-codeInput.scrollTop}px)`;
            // La transformation est plus fluide si elle est dans une frame d'animation
            requestAnimationFrame(() => {
                codeHighlight.style.transform = `translate(${-codeInput.scrollLeft}px, ${-codeInput.scrollTop}px)`;
            });
        }

        function setupMemoryScrollbar(wrapper) {
            if (!wrapper) return;

            const scrollContainer = wrapper.querySelector('.memory-scroll');
            const slider = wrapper.querySelector('.memory-scroll-slider');

            if (!scrollContainer || !slider) return;

            const updateSlider = () => {
                const overflow = scrollContainer.scrollWidth - scrollContainer.clientWidth;
                if (overflow > 0.5) {
                    slider.style.display = 'block';
                    slider.max = overflow;
                    slider.value = Math.min(scrollContainer.scrollLeft, overflow);
                } else {
                    slider.style.display = 'none';
                    slider.value = 0;
                    scrollContainer.scrollLeft = 0;
                }
            };

            slider.addEventListener('input', () => {
                scrollContainer.scrollLeft = Number(slider.value);
            });

            scrollContainer.addEventListener('scroll', () => {
                slider.value = scrollContainer.scrollLeft;
            });

            requestAnimationFrame(updateSlider);
        }

        codeInput.addEventListener('input', () => {
            renderEditorHighlight();
        });

        codeInput.addEventListener('scroll', () => {
            syncHighlightScroll();
        });
        
        window.addEventListener('resize', () => {
            syncHighlightScroll();
            if (interpreter) {
                updateUI();
            }
        });

        // Premi√®re coloration au chargement du script
        renderEditorHighlight();
        
        /**
         * Initialise ou r√©initialise l'interpr√©teur avec le code et les donn√©es d'entr√©e.
         */
        function initializeInterpreter() {
            try {
                // V√©rifier que la classe BrainfuckInterpreter est charg√©e
                if (typeof BrainfuckInterpreter === 'undefined') {
                    throw new Error('BrainfuckInterpreter non charg√©');
                }
                
                // Le gestionnaire de threads est automatiquement initialis√© par chaque nouvelle instance
                
                // R√©initialiser le cache des sorties
                threadOutputsCache.clear();
                console.log('üßπ Cache des sorties vid√©');
                
                // Passage du code et des donn√©es d'entr√©e globales pour le thread principal
                const globalInput = inputData.value;
                interpreter = new BrainfuckInterpreter(codeInput.value, globalInput); 
                
                // Initialiser les donn√©es d'entr√©e pour le thread principal (T0)
                threadInputData.set(0, globalInput);
                
                // Appliquer la limite de threads depuis l'interface
                const maxThreadsInput = document.getElementById('max-threads');
                if (maxThreadsInput && interpreter) {
                    interpreter.setMaxThreads(parseInt(maxThreadsInput.value));
                }
                
                // L'interpr√©teur est initialis√©, debug disponible via interpreter.getAllThreadStates()
                
                updateUI();
                runAllBtn.disabled = false;
                stepBtn.disabled = false;
                outputView.innerHTML = '<span style="color: #999; font-style: italic;">Programme r√©initialis√© - Pr√™t pour l\'ex√©cution</span>';
            } catch (error) {
                alert("Erreur de syntaxe Brainfuck: " + error.message);
                interpreter = null;
            }
        }

        /**
         * Formate la valeur d'une cellule m√©moire pour l'affichage.
         * Si la valeur correspond √† un caract√®re ASCII imprimable, l'affiche.
         * @param {number} value La valeur num√©rique de la cellule.
         * @returns {string} La valeur format√©e en HTML.
         */
        function formatMemoryCell(value) {
            const hexValue = '0x' + value.toString(16).toUpperCase().padStart(2, '0');

            // Les caract√®res imprimables ASCII sont g√©n√©ralement entre 32 (espace) et 126 (~)
            if (value >= 32 && value <= 126) {
                const char = escapeHtml(String.fromCharCode(value));
                return `${hexValue} <span style="color: #aaa; font-weight: bold;">'<span style="color: #0b7dda;">${char}</span>'</span>`;
            }
            // Pour les autres valeurs (non imprimables, null, etc.), on affiche juste le nombre.
            return hexValue;
        }

        /**
         * G√©n√®re les logs d'ex√©cution des threads
         */
        function generateThreadExecutionLog() {
            try {
                console.log('üîÑ DEBUT generateThreadExecutionLog');
                const logElement = document.getElementById('execution-log');
                console.log('üîç logElement found:', logElement);
                if (!logElement) {
                    console.error('‚ùå Element execution-log not found!');
                    return;
                }
                
                console.log('üîÑ Apr√®s v√©rification logElement');
                
                // Debug: afficher l'√©tat de executionHistory
                console.log('üìä GenerateThreadExecutionLog called, executionHistory:', executionHistory);
            console.log('üìä executionHistory.size:', executionHistory.size);
            console.log('üìä executionHistory keys:', Array.from(executionHistory.keys()));
            console.log('üìä executionHistory values:', Array.from(executionHistory.values()));
            
            let html = '<h4>üìä Historique d\'ex√©cution</h4>';
            console.log('üìä HTML initial cr√©√©:', html);
            
            if (executionHistory.size === 0) {
                console.log('üìä BRANCH: executionHistory est vide');
                html += '<p style="color: #666; font-style: italic;">Aucune ex√©cution pour le moment</p>';
                html += '<p style="color: #999; font-size: 12px;">Debug: executionHistory.size = ' + executionHistory.size + '</p>';
                
                // WORKAROUND: Si les stats de l'interpr√©teur existent, les afficher directement
                if (interpreter && interpreter.stats && interpreter.stats.totalSteps > 0) {
                    console.log('üîß WORKAROUND: Utilisation des stats de l\'interpr√©teur directement');
                    const stats = interpreter.stats;
                    html += '<div style="background: #fff3cd; padding: 10px; margin: 10px 0; border-radius: 5px;">';
                    html += '<h5>üìä Statistiques depuis l\'interpr√©teur :</h5>';
                    html += `<p><strong>Total d'√©tapes:</strong> ${stats.totalSteps}</p>`;
                    html += `<p><strong>Temps d'ex√©cution:</strong> ${(stats.executionEndTime - stats.executionStartTime).toFixed(2)}ms</p>`;
                    html += `<p><strong>Instructions ex√©cut√©es:</strong></p><ul>`;
                    for (const [cmd, count] of Object.entries(stats.instructionCounts)) {
                        if (count > 0) {
                            html += `<li>${cmd}: ${count} fois</li>`;
                        }
                    }
                    html += '</ul></div>';
                }
            } else {
                console.log('üìä BRANCH: executionHistory contient des donn√©es');
                console.log('üìä Entering statistics display logic...');
                html += '<div class="execution-stats">';
                
                // Statistiques globales
                const totalSteps = Array.from(executionHistory.values()).reduce((sum, steps) => sum + steps, 0);
                html += `<div class="stat-item">
                    <span class="stat-label">Total d'√©tapes:</span>
                    <span class="stat-value">${totalSteps}</span>
                </div>`;
                
                html += `<div class="stat-item">
                    <span class="stat-label">Threads actifs:</span>
                    <span class="stat-value">${executionHistory.size}</span>
                </div>`;
                
                html += '</div>';
                
                // D√©tails par thread
                html += '<div class="thread-logs">';
                for (const [threadId, steps] of executionHistory) {
                    const percentage = totalSteps > 0 ? ((steps / totalSteps) * 100).toFixed(1) : 0;
                    html += `
                        <div class="thread-log-item">
                            <div class="thread-log-header">
                                <span class="thread-id">Thread T${threadId}</span>
                                <span class="thread-steps">${steps} √©tapes (${percentage}%)</span>
                            </div>
                            <div class="thread-progress-bar">
                                <div class="thread-progress-fill" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    `;
                }
                html += '</div>';
            }
            
            console.log('üìä Setting innerHTML:', html);
            logElement.innerHTML = html;
            console.log('‚úÖ Statistics updated successfully');
            
            } catch (error) {
                console.error('üí• ERREUR dans generateThreadExecutionLog:', error);
                console.error('üí• Stack trace:', error.stack);
                
                // Plan B: affichage minimal
                const logElement = document.getElementById('execution-log');
                if (logElement) {
                    logElement.innerHTML = `
                        <h4>üìä Historique d'ex√©cution</h4>
                        <div style="background: #ffebee; color: #c62828; padding: 10px; border-radius: 5px;">
                            ‚ùå Erreur lors de l'affichage des statistiques:<br>
                            ${error.message}
                        </div>
                    `;
                }
            }
        }

        /**
         * Met √† jour tous les √©l√©ments de l'interface utilisateur.
         */
        function updateUI() {
            if (!interpreter) return;

            const state = interpreter.getState();

            // 1. Mise √† jour des compteurs et sortie avec annotations de threads
            updateGlobalOutput();
            ipView.textContent = state.ip;
            ptrView.textContent = state.ptr;

            // 2. Visualisation du code et du Pointeur d'Instruction (IP)
            
            const activeInstructionIndex = state.code.length === 0
                ? null
                : (state.ip < state.code.length ? state.ip : state.code.length - 1);
            const activeOriginalIndex = (!state.codeMap || state.codeMap.length === 0)
                ? null
                : (state.ip < state.codeMap.length ? state.codeMap[state.ip] : state.codeMap[state.codeMap.length - 1]);

            codeView.innerHTML = buildHighlightedHtml(state.code, activeInstructionIndex);
            renderEditorHighlight(activeOriginalIndex);


            // 3. Visualisation de la m√©moire et du Pointeur de Cellule (PTR)
            let memDisplay = '<table>';
            const windowRadius = 7;
            const memoryLength = state.memoryFull.length;
            const start = Math.max(0, state.ptr - windowRadius);
            const end = Math.min(state.ptr + windowRadius + 1, memoryLength);

            // Ligne 1: Index (PTR)
            memDisplay += '<tr class="header-row">';
            if (start > 0) {
                memDisplay += '<td class="ellipsis-cell">‚Ä¶</td>';
            }
            for (let i = start; i < end; i++) {
                memDisplay += `<td>${i}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td class="ellipsis-cell">‚Ä¶</td>';
            }
            memDisplay += '</tr>';

            // Ligne 2: Valeurs (Contenu de la cellule)
            memDisplay += '<tr>';
            if (start > 0) {
                memDisplay += '<td class="ellipsis-cell">‚Ä¶</td>';
            }
            for (let i = start; i < end; i++) {
                const cellClass = i === state.ptr ? 'active-cell' : '';
                const cellContent = formatMemoryCell(state.memoryFull[i]);
                memDisplay += `<td class="${cellClass}">${cellContent}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td class="ellipsis-cell">‚Ä¶</td>';
            }
            memDisplay += '</tr>';
            memDisplay += '</table>';

            memoryView.innerHTML = `
                <div class="memory-scroll-wrapper">
                    <div class="memory-scroll" role="region" aria-label="Fen√™tre m√©moire d√©filable">${memDisplay}</div>
                    <input type="range" class="memory-scroll-slider" min="0" value="0" step="1" aria-label="D√©filement horizontal de la m√©moire">
                </div>
            `;

            const memoryWrapper = memoryView.querySelector('.memory-scroll-wrapper');
            setupMemoryScrollbar(memoryWrapper);

            // Centrer automatiquement la vue m√©moire sur la cellule active
            const activeCellElement = memoryWrapper.querySelector('.active-cell');
            const scrollContainer = memoryWrapper.querySelector('.memory-scroll');
            if (activeCellElement && scrollContainer) {
                const containerWidth = scrollContainer.offsetWidth;
                const cellLeft = activeCellElement.offsetLeft;
                const cellWidth = activeCellElement.offsetWidth;
                // Calcule la position de d√©filement pour centrer la cellule
                const scrollTarget = cellLeft - (containerWidth / 2) + (cellWidth / 2);
                scrollContainer.scrollLeft = scrollTarget;
            }

            // 4. Mise √† jour des informations de threading
            updateThreadInfo(state);
            
            // Nettoyer les threads termin√©s p√©riodiquement
            if (state.totalThreads > 1 && interpreter) {
                const cleaned = interpreter.cleanupHaltedThreads();
                if (cleaned > 0) {
                    console.log(`üßπ Nettoyage: ${cleaned} threads termin√©s supprim√©s`);
                }
            }
            
            // 5. Afficher la vue multi-thread si n√©cessaire et g√©rer les zones I/O
            if (state.totalThreads > 1) {
                updateMultiThreadView();
                document.getElementById('multi-thread-view').style.display = 'block';
                
                // Masquer l'√©tat single-thread en mode multi-thread (√©viter la redondance)
                document.getElementById('single-thread-state').style.display = 'none';
                
                // Basculer vers les zones d'entr√©e par thread
                document.getElementById('single-thread-input').style.display = 'none';
                updateMultiThreadInputs();
                document.getElementById('multi-thread-inputs').style.display = 'block';
                
                // Afficher le bouton Step Single en mode multi-thread
                stepSingleBtn.style.display = 'inline-block';
                switchThreadBtn.style.display = 'inline-block';
                stepBtn.textContent = 'üë£ Step (Tous Threads)';
            } else {
                document.getElementById('multi-thread-view').style.display = 'none';
                
                // Afficher l'√©tat single-thread en mode single-thread
                document.getElementById('single-thread-state').style.display = 'block';
                
                // Revenir √† la zone d'entr√©e globale
                document.getElementById('single-thread-input').style.display = 'block';
                document.getElementById('multi-thread-inputs').style.display = 'none';
                
                // Masquer le bouton Step Single en mode single-thread
                stepSingleBtn.style.display = 'none';
                switchThreadBtn.style.display = 'none';
                stepBtn.textContent = 'üë£ Ex√©cuter Pas √† Pas';
            }

            // 5.5. G√©n√©rer les logs d'ex√©cution
            generateThreadExecutionLog();

            // 6. Gestion de la fin du programme
            if (state.halted) {
                runAllBtn.disabled = true;
                stepBtn.disabled = true;
                const outputView = document.getElementById('output-view');
                if (outputView && !outputView.innerHTML.includes("termin√©")) {
                    outputView.innerHTML += "\n\n\n--- Programme termin√© ---";
                }
            } else if (interpreter && interpreter.threadManager) {
                // V√©rifier si tous les threads multi-thread sont termin√©s
                const allThreadStates = interpreter.getAllThreadStates();
                const activeThreads = allThreadStates.filter(t => !t.halted);
                
                if (allThreadStates.length > 1 && activeThreads.length === 0) {
                    console.log('üéØ Tous les threads multi-thread sont termin√©s (depuis updateUI)');
                    runAllBtn.disabled = true;
                    stepBtn.disabled = true;
                    const outputView = document.getElementById('output-view');
                    if (outputView && !outputView.innerHTML.includes("termin√©")) {
                        outputView.innerHTML += "\n\n\n--- Programme termin√© ---";
                    }
                }
            }
        }

        // Nouvelle fonction pour les informations de thread
        function updateThreadInfo(state) {
            const threadInfo = document.getElementById('thread-info');
            let infoHTML = `<strong>üîó Thread T${state.threadId}</strong>`;
            
            if (state.parentId !== null) {
                infoHTML += ` (Enfant de T${state.parentId})`;
            } else {
                infoHTML += ` (Principal)`;
            }
            
            // Calculer les threads r√©els
            const manager = interpreter ? interpreter.threadManager : null;
            let activeCount = 0;
            let totalCount = 0;
            if (manager) {
                for (const [threadId, thread] of manager.threads) {
                    totalCount++;
                    if (!thread.halted) {
                        activeCount++;
                    }
                }
            } else {
                activeCount = totalCount = 1;
            }
            
            infoHTML += `<br><strong>Threads:</strong> ${activeCount} actifs`;
            if (totalCount > activeCount) {
                infoHTML += ` (${totalCount - activeCount} termin√©s)`;
            }
            
            if (state.children.length > 0) {
                infoHTML += `<br><strong>Enfants Cr√©√©s:</strong> [${state.children.map(id => `T${id}`).join(', ')}]`;
            }
            
            if (state.isForked) {
                infoHTML += `<br><span style="color: #ff6b35;">üîÄ Ce thread a √©t√© cr√©√© par fork</span>`;
            }
            
            // NOUVEAU: Ajouter indicateur du thread actuel
            if (interpreter && interpreter.threadManager) {
                const manager = interpreter.threadManager;
                const activeThreadsFromManager = [];
                for (const [threadId, thread] of manager.threads) {
                    if (!thread.halted) {
                        activeThreadsFromManager.push(thread);
                    }
                }
                
                if (activeThreadsFromManager.length > 1) {
                    // CORRECTION: V√©rifier l'√©tat r√©el du thread dans le gestionnaire
                    const currentThreadInManager = manager.threads.get(state.threadId);
                    const isCurrentThreadHalted = currentThreadInManager ? currentThreadInManager.halted : state.halted;
                    
                    if (isCurrentThreadHalted) {
                        infoHTML += `<br><span style="color: #ff4444; font-weight: bold;">üíÄ Ce thread est TERMIN√â</span>`;
                        infoHTML += `<br><span style="font-size: 12px; color: #666;">üí° Utilisez "Changer Thread" pour basculer vers un thread actif</span>`;
                    } else {
                        infoHTML += `<br><span style="color: #2196F3; font-weight: bold;">üëë Thread actuel pour "Step Single": T${state.threadId}</span>`;
                        infoHTML += `<br><span style="font-size: 12px; color: #666;">üí° "Step Single" = Ex√©cuter CE thread | "Changer Thread" = Basculer vers un autre</span>`;
                    }
                } else if (activeThreadsFromManager.length === 1) {
                    const currentThreadInManager = manager.threads.get(state.threadId);
                    const isCurrentThreadHalted = currentThreadInManager ? currentThreadInManager.halted : state.halted;
                    
                    if (isCurrentThreadHalted) {
                        infoHTML += `<br><span style="color: #ff4444; font-weight: bold;">üíÄ Ce thread est TERMIN√â - Aucun thread actif</span>`;
                    } else {
                        infoHTML += `<br><span style="color: #4CAF50; font-weight: bold;">üèÜ Dernier thread actif</span>`;
                    }
                }
            }
            
            threadInfo.innerHTML = infoHTML;
        }

        // Nouvelle fonction pour la vue multi-thread
        function updateMultiThreadView() {
            if (!interpreter) return;
            
            const allStates = interpreter.getAllThreadStates();
            console.log('üîç Debug updateMultiThreadView - Nombre de threads:', allStates.length);
            console.log('üîç Debug updateMultiThreadView - √âtats des threads:', allStates);
            const container = document.getElementById('threads-container');
            
            container.innerHTML = '';
            
            allStates.forEach((state, index) => {
                console.log(`üîç Debug - Affichage thread T${state.threadId}, halted: ${state.halted}, IP: ${state.ip}/${state.code.length}`);
                const threadDiv = document.createElement('div');
                const currentThreadId = interpreter ? interpreter.getState().threadId : 0;
                const isCurrentThread = state.threadId === currentThreadId;
                
                let className = 'thread-state ';
                if (isCurrentThread) {
                    className += 'current ';
                } else if (state.halted) {
                    className += 'halted ';
                } else {
                    className += 'active ';
                }
                threadDiv.className = className.trim();
                threadDiv.style.position = 'relative';
                
                // Calculer le progr√®s du thread (pourcentage d'instructions ex√©cut√©es)
                const progress = state.code.length > 0 ? (state.ip / state.code.length) * 100 : 0;
                
                // En-t√™te du thread avec indicateur d'ex√©cution
                const headerHTML = `
                    <div class="thread-header">
                        <span>üîó Thread T${state.threadId} ${state.parentId !== null ? `(Parent: T${state.parentId})` : '(Principal)'} ${isCurrentThread ? 'üëë Actuel' : ''}</span>
                        <span>${state.halted ? 'ÔøΩ TERMIN√â' : '‚ñ∂Ô∏è Actif'}</span>
                    </div>
                    <div class="thread-progress-bar">
                        <div class="thread-progress-fill" style="width: ${Math.min(progress, 100)}%"></div>
                    </div>
                `;
                
                // Zones d'entr√©e et de sortie par thread
                const ioHTML = generateThreadIOView(state);
                
                // Informations de base avec chronologie
                const steps = executionHistory.get(state.threadId) || 0;
                const detailsHTML = `
                    <div class="thread-details">
                        <strong>PTR:</strong> ${state.ptr} | 
                        <strong>IP:</strong> ${state.ip}/${state.code.length} | 
                        <strong>Cellule:</strong> ${state.memoryFull[state.ptr] || 0} | 
                        <strong>√âtapes:</strong> ${steps}<br>
                        <strong>Instruction:</strong> "${state.currentInstruction || 'FIN'}" | 
                        <strong>Forks cr√©√©s:</strong> ${state.forkCount || 0}<br>
                        ${state.children.length > 0 ? `<strong>Enfants:</strong> [${state.children.map(id => `T${id}`).join(', ')}]` : ''}
                        <div class="thread-timeline">
                            üìä Progr√®s: ${progress.toFixed(1)}% | 
                            ‚è±Ô∏è Derni√®re activit√©: √âtape ${globalStepCounter}
                        </div>
                    </div>
                `;
                
                // Contenu selon le mode d'affichage
                let contentHTML = headerHTML + ioHTML + detailsHTML;
                
                if (showDetailedThreadView) {
                    // Visualisation de la m√©moire (fen√™tre autour du PTR)
                    const memoryHTML = generateThreadMemoryView(state);
                    
                    // Code en cours d'ex√©cution avec mise en √©vidence
                    const codeHTML = generateThreadCodeView(state);
                    
                    // Log d'ex√©cution r√©cent
                    const logHTML = generateThreadExecutionLog(state.threadId);
                    
                    contentHTML += memoryHTML + codeHTML + logHTML;
                }
                
                threadDiv.innerHTML = contentHTML;
                container.appendChild(threadDiv);
                
                // Configurer les gestionnaires d'√©v√©nements pour les zones I/O
                setupThreadIOHandlers(threadDiv, state.threadId);
                
                // Ajouter effet visuel lors de l'ex√©cution
                if (!state.halted && Math.random() < 0.3) { // Animation occasionnelle
                    setTimeout(() => {
                        const indicator = document.createElement('div');
                        indicator.className = 'thread-execution-indicator executing';
                        threadDiv.appendChild(indicator);
                        setTimeout(() => indicator.remove(), 500);
                    }, index * 100);
                }
            });
        }

        // G√©n√®re la vue I/O pour un thread (entr√©e seulement, sortie globale)
        function generateThreadIOView(state) {
            const inputValue = threadInputData.get(state.threadId) || '';
            
            if (showDetailedThreadView) {
                // Vue d√©taill√©e avec zone d'entr√©e compl√®te
                return `
                    <div class="thread-io">
                        <div class="thread-io-section">
                            <label class="thread-io-label">üì• Donn√©es d'Entr√©e (Input):</label>
                            <textarea class="thread-input" 
                                      data-thread-id="${state.threadId}" 
                                      placeholder="Donn√©es pour les commandes ',' du thread T${state.threadId}">${inputValue}</textarea>
                        </div>
                    </div>
                `;
            } else {
                // Vue compacte avec zone d'entr√©e r√©duite
                return `
                    <div class="thread-io">
                        <div class="thread-io-section">
                            <label class="thread-io-label">üì• Input T${state.threadId}:</label>
                            <textarea class="thread-input" 
                                      data-thread-id="${state.threadId}" 
                                      placeholder="Input T${state.threadId}">${inputValue}</textarea>
                        </div>
                    </div>
                `;
            }
        }



        // Callback appel√© √† chaque output de thread
        window.onThreadOutput = function(threadId, currentOutput) {
            console.log(`üéØ Thread T${threadId} output update: length=${currentOutput.length}, chars=[${currentOutput.split('').map(c => c.charCodeAt(0)).join(',')}]`);
            threadOutputsCache.set(threadId, currentOutput);
        };

        // Callback appel√© √† la fin de runAllThreads pour capturer les outputs finaux
        window.captureThreadOutputsForRunAll = function(results) {
            console.log('üéØ captureThreadOutputsForRunAll called with results:', results);
            results.forEach(result => {
                if (result.output && result.output.length > 0) {
                    console.log(`üéØ Capturing final output for T${result.threadId}: length=${result.output.length}`);
                    threadOutputsCache.set(result.threadId, result.output);
                }
            });
            console.log('üéØ Final cache after runAll:', Array.from(threadOutputsCache.entries()));
        };

        // Capture les sorties des threads pendant l'ex√©cution
        function captureThreadOutputs() {
            console.log('üì¶ DEBUG captureThreadOutputs: Starting capture...');
            
            if (!interpreter) {
                console.log('üì¶ DEBUG: No interpreter found');
                return;
            }
            
            // Essayer d'abord la m√©thode normale
            let allStates = interpreter.getAllThreadStates();
            console.log('üì¶ DEBUG: interpreter.getAllThreadStates() =', allStates);
            
            // Fallback vers le gestionnaire global
            if (allStates.length === 0 && BrainfuckInterpreter.threadManager) {
                console.log('üì¶ DEBUG: Trying global thread manager');
                allStates = [];
                for (const [threadId, thread] of BrainfuckInterpreter.threadManager.threads) {
                    const state = thread.getState();
                    console.log(`üì¶ DEBUG: Thread T${threadId} state:`, state);
                    allStates.push(state);
                }
                console.log('üì¶ DEBUG: Global states found:', allStates);
            }
            
            // Si toujours aucun √©tat, v√©rification directe des threads
            if (allStates.length === 0) {
                console.log('üì¶ DEBUG: No states found, checking threads directly...');
                if (BrainfuckInterpreter.threadManager && BrainfuckInterpreter.threadManager.threads) {
                    console.log('üì¶ DEBUG: Direct thread inspection:');
                    for (const [tid, thread] of BrainfuckInterpreter.threadManager.threads) {
                        console.log(`   T${tid}: halted=${thread.halted}, output="${thread.output}", length=${(thread.output||'').length}`);
                        if (thread.output && thread.output.length > 0) {
                            threadOutputsCache.set(tid, thread.output);
                        }
                    }
                }
            }
            
            // Mettre √† jour le cache avec les sorties actuelles
            let updatedCount = 0;
            allStates.forEach(state => {
                const output = state.output || '';
                console.log(`üì¶ DEBUG: Thread T${state.threadId} output: "${output}" (length: ${output.length})`);
                if (output.length > 0) {
                    threadOutputsCache.set(state.threadId, output);
                    updatedCount++;
                }
            });
            
            console.log(`üì¶ Cache des sorties mis √† jour: ${updatedCount} threads with output`);
            console.log('üì¶ Current cache:', Array.from(threadOutputsCache.entries()));
        }

        // Met √† jour la sortie globale unifi√©e avec annotations des threads
        function updateGlobalOutput() {
            if (!interpreter) {
                outputView.textContent = "En attente d'ex√©cution...";
                document.getElementById('output-legend').style.display = 'none';
                return;
            }
            
            // Capturer les sorties des threads actifs seulement si le cache est vide
            // (pour √©viter d'√©craser le cache rempli par runAllThreads)
            if (threadOutputsCache.size === 0) {
                console.log('üé® DEBUG: Cache vide, capturing thread outputs...');
                captureThreadOutputs();
            } else {
                console.log('üé® DEBUG: Cache non-vide, skipping capture to preserve data');
            }
            
            const allStates = interpreter.getAllThreadStates();
            const isMultiThread = allStates.length > 1 || threadOutputsCache.size > 1;
            
            console.log('üé® DEBUG updateGlobalOutput: allStates =', allStates);
            console.log('üé® DEBUG updateGlobalOutput: threadOutputsCache =', threadOutputsCache);
            console.log('üé® DEBUG updateGlobalOutput: isMultiThread =', isMultiThread);
            
            // Utiliser le cache si nous avons des outputs captur√©s, m√™me en single-thread
            if (threadOutputsCache.size > 0) {
                console.log('üé® DEBUG: Taking cache path with', threadOutputsCache.size, 'threads');
                // Mode avec cache : utiliser les sorties captur√©es
                const globalOutput = buildAnnotatedOutput(threadOutputsCache);
                
                console.log('üé® DEBUG updateGlobalOutput: setting innerHTML to:', globalOutput);
                
                // Afficher avec le HTML color√©
                outputView.innerHTML = globalOutput;
                console.log('üé® DEBUG: After setting innerHTML, outputView.innerHTML =', outputView.innerHTML);
                
                // Diagnostic complet
                const outputElement = document.getElementById('output-view');
                console.log('üîç DIAGNOSTIC outputView element:', outputElement);
                console.log('üîç DIAGNOSTIC tagName:', outputElement.tagName);
                console.log('üîç DIAGNOSTIC computed styles:', window.getComputedStyle(outputElement));
                console.log('üîç DIAGNOSTIC color property:', window.getComputedStyle(outputElement).color);
                console.log('üîç DIAGNOSTIC background property:', window.getComputedStyle(outputElement).backgroundColor);
                
                // Chercher le span avec la classe thread-output-T0
                setTimeout(() => {
                    const threadSpan = outputElement.querySelector('.thread-output-T0');
                    if (threadSpan) {
                        console.log('üîç DIAGNOSTIC thread span found:', threadSpan);
                        console.log('üîç DIAGNOSTIC thread span styles:', window.getComputedStyle(threadSpan));
                        console.log('üîç DIAGNOSTIC thread span color:', window.getComputedStyle(threadSpan).color);
                        console.log('üîç DIAGNOSTIC thread span background:', window.getComputedStyle(threadSpan).backgroundColor);
                    } else {
                        console.log('üîç DIAGNOSTIC: No thread span found!');
                    }
                }, 100);
                
                // Afficher la l√©gende des threads s'il y a des outputs dans le cache
                if (threadOutputsCache.size > 0) {
                    // Cr√©er des √©tats simul√©s pour la l√©gende bas√©s sur le cache
                    const simulatedStates = [];
                    for (const [threadId, output] of threadOutputsCache) {
                        simulatedStates.push({
                            threadId: threadId,
                            parentId: threadId === 0 ? null : 0, // Supposer que T0 est le parent
                            output: output
                        });
                    }
                    updateThreadLegend(simulatedStates);
                    
                    if (threadOutputsCache.size > 1) {
                        document.getElementById('output-legend').style.display = 'block';
                    } else {
                        document.getElementById('output-legend').style.display = 'none';
                    }
                } else {
                    document.getElementById('output-legend').style.display = 'none';
                }
                
            } else {
                console.log('üé® DEBUG: Taking single-thread path (cache is empty)');
                // Mode single-thread : sortie simple avec formatage des caract√®res
                const state = interpreter.getState();
                const output = state.output || '';
                
                if (output.length > 0) {
                    // Formatter chaque caract√®re pour afficher les non-imprimables en hexa
                    let formattedOutput = '';
                    for (let i = 0; i < output.length; i++) {
                        const charCode = output.charCodeAt(i);
                        formattedOutput += formatOutputChar(charCode);
                    }
                    outputView.innerHTML = formattedOutput;
                } else {
                    outputView.innerHTML = '<span style="color: #999; font-style: italic;">Aucune sortie produite</span>';
                }
                
                document.getElementById('output-legend').style.display = 'none';
            }
        }

        // Formate un caract√®re pour l'affichage (imprimable ou hexa) avec couleur de thread
        function formatOutputChar(charCode, threadId = null) {
            // Les caract√®res imprimables ASCII sont g√©n√©ralement entre 32 (espace) et 126 (~)
            if (charCode >= 32 && charCode <= 126) {
                // Pour les caract√®res imprimables, on laisse le wrapper du thread g√©rer la couleur
                return escapeHtml(String.fromCharCode(charCode));
            } else {
                // Pour les caract√®res non imprimables, afficher en hexad√©cimal
                const hexValue = '0x' + charCode.toString(16).toUpperCase().padStart(2, '0');
                
                // Noms sp√©ciaux pour certains caract√®res courants
                let charName = '';
                switch (charCode) {
                    case 0: charName = 'NULL'; break;
                    case 7: charName = 'BELL'; break;
                    case 8: charName = 'BACKSPACE'; break;
                    case 9: charName = 'TAB'; break;
                    case 10: charName = 'LF (Nouvelle ligne)'; break;
                    case 13: charName = 'CR (Retour chariot)'; break;
                    case 27: charName = 'ESC'; break;
                    default: charName = `Code ASCII ${charCode}`;
                }
                
                // Utiliser les classes CSS au lieu des styles inline
                return `<span class="hex-char" title="${charName}">${hexValue}</span>`;
            }
        }

        // Construit une sortie annot√©e avec couleurs pour identifier les threads
        function buildAnnotatedOutput(threadOutputs) {
            let result = '';
            let hasContent = false;
            
            console.log('üé® DEBUG buildAnnotatedOutput: threadOutputs =', threadOutputs);
            
            // Trier les threads par ID pour un affichage coh√©rent
            const sortedThreads = Array.from(threadOutputs.entries()).sort((a, b) => a[0] - b[0]);
            
            sortedThreads.forEach(([threadId, output]) => {
                if (output && output.length > 0) {
                    console.log(`üé® DEBUG: Processing thread T${threadId}, output length: ${output.length}`);
                    
                    if (hasContent) {
                        // Ajouter un petit s√©parateur visuel entre les outputs des threads
                        result += '<span style="color: #ccc; margin: 0 2px;">|</span>';
                    }
                    
                    // Formatter chaque caract√®re de la sortie avec la couleur du thread
                    let formattedOutput = '';
                    for (let i = 0; i < output.length; i++) {
                        const charCode = output.charCodeAt(i);
                        const formatted = formatOutputChar(charCode, threadId);
                        formattedOutput += formatted;
                    }
                    
                    // Utiliser les classes CSS avec identification du thread
                    const threadSpan = `<span class="thread-output-T${threadId}" title="Thread T${threadId}">${formattedOutput}</span>`;
                    console.log(`üé® DEBUG: Thread T${threadId} span:`, threadSpan);
                    
                    result += threadSpan;
                    hasContent = true;
                }
            });
            
            // Si aucun thread n'a produit de sortie, afficher un message neutre
            if (!hasContent) {
                return '<span style="color: #999; font-style: italic;">Aucune sortie produite</span>';
            }
            
            console.log('üé® DEBUG: Final result HTML:', result);
            return result;
        }

        // Met √† jour la l√©gende des couleurs de threads
        function updateThreadLegend(allStates) {
            const legendContainer = document.getElementById('thread-colors-legend');
            if (!legendContainer) return;
            
            let legendHTML = '';
            const threadColors = [
                '#2196F3', '#4CAF50', '#FF9800', '#9C27B0', 
                '#F44336', '#795548', '#607D8B', '#E91E63'
            ];
            
            allStates.forEach((state, index) => {
                const color = threadColors[state.threadId % threadColors.length];
                const hasNonPrintable = state.output && /[\x00-\x1F\x7F-\xFF]/.test(state.output);
                const badgeExample = hasNonPrintable ? `<span class="hex-char" style="border-color: ${color}; background: ${color}20; color: ${color}; font-size: 0.8em;">0x0A</span>` : '';
                
                legendHTML += `
                    <span class="thread-legend-item">
                        <span class="thread-legend-color" style="background-color: ${color};"></span>
                        T${state.threadId}${state.parentId !== null ? ` (parent: T${state.parentId})` : ' (principal)'}
                        ${badgeExample}
                    </span>
                `;
            });
            
            legendContainer.innerHTML = legendHTML;
        }

        // Met √† jour les zones d'entr√©e en mode multi-thread
        function updateMultiThreadInputs() {
            if (!interpreter) return;
            
            const allStates = interpreter.getAllThreadStates();
            const container = document.getElementById('multi-thread-inputs');
            if (!container) return;
            
            container.innerHTML = '';
            
            allStates.forEach(state => {
                const inputValue = threadInputData.get(state.threadId) || '';
                const inputDiv = document.createElement('div');
                inputDiv.className = 'multi-thread-input';
                
                inputDiv.innerHTML = `
                    <label class="multi-thread-input-label">
                        üì• Thread T${state.threadId} - Donn√©es d'Entr√©e:
                    </label>
                    <textarea data-thread-id="${state.threadId}" 
                              placeholder="Donn√©es pour les commandes ',' du thread T${state.threadId}">${inputValue}</textarea>
                `;
                
                container.appendChild(inputDiv);
                
                // Configurer les gestionnaires d'√©v√©nements
                const textarea = inputDiv.querySelector('textarea');
                if (textarea) {
                    textarea.addEventListener('input', (e) => {
                        const newValue = e.target.value;
                        threadInputData.set(state.threadId, newValue);
                        console.log(`üìù Input thread T${state.threadId} mis √† jour: "${newValue}"`);
                        
                        // Mettre √† jour l'input du thread correspondant dans l'interpr√©teur
                        if (interpreter && interpreter.threadManager) {
                            const thread = interpreter.threadManager.threads.get(state.threadId);
                            if (thread) {
                                // Comparer avec la version cha√Æne du tableau actuel
                                const currentInputString = Array.isArray(thread.input) ? thread.input.join('') : (thread.input || '');
                                if (currentInputString !== newValue) {
                                    thread.input = newValue.split(''); // Convertir en tableau
                                    // Pas de inputPointer car BrainfuckInterpreter utilise shift()
                                    console.log(`üîÑ Thread T${state.threadId} input synchronis√©: "${newValue}"`);
                                }
                            }
                        }
                    });
                }
            });
        }

        // Configure les gestionnaires d'√©v√©nements pour les zones I/O d'un thread
        function setupThreadIOHandlers(threadDiv, threadId) {
            const inputArea = threadDiv.querySelector(`textarea[data-thread-id="${threadId}"]`);
            if (inputArea) {
                inputArea.addEventListener('input', (e) => {
                    const newValue = e.target.value;
                    threadInputData.set(threadId, newValue);
                    console.log(`üìù Input thread T${threadId} mis √† jour: "${newValue}"`);
                    
                    // Mettre √† jour l'input du thread correspondant dans l'interpr√©teur
                    if (interpreter && interpreter.threadManager) {
                        const thread = interpreter.threadManager.threads.get(threadId);
                        if (thread) {
                            // Comparer avec la version cha√Æne du tableau actuel
                            const currentInputString = Array.isArray(thread.input) ? thread.input.join('') : (thread.input || '');
                            if (currentInputString !== newValue) {
                                thread.input = newValue.split(''); // Convertir en tableau
                                // Pas de inputPointer car BrainfuckInterpreter utilise shift()
                                console.log(`üîÑ Thread T${threadId} input synchronis√©: "${newValue}"`);
                            }
                        }
                    }
                });
            }
        }

        // G√©n√®re un log d'ex√©cution pour un thread
        function generateThreadExecutionLog(threadId) {
            const history = executionHistory.get(threadId) || 0;
            const logs = [
                `√âtape ${Math.max(0, globalStepCounter - 2)}: Instruction ex√©cut√©e`,
                `√âtape ${Math.max(0, globalStepCounter - 1)}: √âtat mis √† jour`,
                `√âtape ${globalStepCounter}: √âtat actuel`
            ];
            
            return `
                <div class="execution-log">
                    <strong>üìù Log d'ex√©cution:</strong><br>
                    ${logs.slice(-3).map(log => `‚Ä¢ ${log}`).join('<br>')}
                </div>
            `;
        }

        // G√©n√®re la vue m√©moire pour un thread
        function generateThreadMemoryView(state) {
            const windowRadius = 5; // Fen√™tre plus petite pour √©conomiser l'espace
            const memoryLength = state.memoryFull.length;
            const start = Math.max(0, state.ptr - windowRadius);
            const end = Math.min(state.ptr + windowRadius + 1, memoryLength);

            let memDisplay = '<div class="thread-memory"><strong>M√©moire:</strong><div class="thread-memory-scroll"><table>';
            
            // Ligne 1: Index (PTR)
            memDisplay += '<tr class="header-row">';
            if (start > 0) {
                memDisplay += '<td>‚Ä¶</td>';
            }
            for (let i = start; i < end; i++) {
                memDisplay += `<td>${i}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td>‚Ä¶</td>';
            }
            memDisplay += '</tr>';

            // Ligne 2: Valeurs
            memDisplay += '<tr>';
            if (start > 0) {
                memDisplay += '<td>‚Ä¶</td>';
            }
            for (let i = start; i < end; i++) {
                const cellClass = i === state.ptr ? 'active-cell' : '';
                const value = state.memoryFull[i];
                const hexValue = '0x' + value.toString(16).toUpperCase().padStart(2, '0');
                let cellContent = hexValue;
                
                // Ajouter le caract√®re ASCII si imprimable
                if (value >= 32 && value <= 126) {
                    const char = escapeHtml(String.fromCharCode(value));
                    cellContent += `<br>'${char}'`;
                }
                
                memDisplay += `<td class="${cellClass}">${cellContent}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td>‚Ä¶</td>';
            }
            memDisplay += '</tr>';
            memDisplay += '</table></div></div>';
            
            return memDisplay;
        }

        // G√©n√®re la vue code pour un thread
        function generateThreadCodeView(state) {
            if (!state.code || state.code.length === 0) {
                return '<div class="thread-code"><em>Aucun code</em></div>';
            }
            
            // Afficher une fen√™tre autour de l'IP actuel
            const windowRadius = 10;
            const start = Math.max(0, state.ip - windowRadius);
            const end = Math.min(state.ip + windowRadius + 1, state.code.length);
            
            let codeDisplay = '<div class="thread-code"><strong>Code (IP=' + state.ip + '):</strong><br>';
            
            if (start > 0) {
                codeDisplay += '‚Ä¶';
            }
            
            for (let i = start; i < end; i++) {
                const char = state.code[i];
                if (i === state.ip) {
                    // Instruction actuelle en surbrillance
                    codeDisplay += `<span style="background: #ff9900; color: white; padding: 1px 2px; border-radius: 2px;">${escapeHtml(char)}</span>`;
                } else {
                    // Coloration normale
                    const tokenClass = BF_TOKEN_CLASSES[char] || 'bf-comment';
                    codeDisplay += `<span class="${tokenClass}">${escapeHtml(char)}</span>`;
                }
            }
            
            if (end < state.code.length) {
                codeDisplay += '‚Ä¶';
            }
            
            codeDisplay += '</div>';
            return codeDisplay;
        }

        // --- Fonction de test pour debug des statistiques ---
        window.testStats = function() {
            console.log('üß™ Test forc√© des statistiques');
            executionHistory.clear();
            executionHistory.set(0, 10);
            executionHistory.set(1, 5);
            console.log('üß™ executionHistory test:', executionHistory);
            generateThreadExecutionLog();
        };
        
        // --- Gestionnaires d'√©v√©nements ---

        runAllBtn.addEventListener('click', () => {
            // R√©initialiser s'il n'y a pas d'interpr√©teur ou si l'ex√©cution pr√©c√©dente est termin√©e
            if (!interpreter || interpreter.getState().halted) initializeInterpreter();
            if (interpreter) {
                try {
                    const state = interpreter.getState();
                    console.log('üîç Debug - state.totalThreads:', state.totalThreads);
                    console.log('üîç Debug - getAllThreadStates().length:', interpreter.getAllThreadStates().length);
                    
                    // Toujours d√©marrer en mode multi-thread pour d√©tecter les forks dynamiquement
                    console.log('üöÄ D√©marrage ex√©cution multi-thread (d√©tection dynamique des forks)...');
                    const results = interpreter.runAllThreads();
                    console.log('‚úÖ Ex√©cution termin√©e. R√©sultats:', results);
                    
                    // Log des r√©sultats sans popup
                    if (results.length > 1) {
                        console.log(`‚úÖ Ex√©cution multi-thread termin√©e avec ${results.length} threads`);
                        results.forEach(r => {
                            console.log(`Thread T${r.threadId}: "${r.output}"`);
                        });
                    } else {
                        console.log('‚úÖ Ex√©cution termin√©e (pas de forks d√©tect√©s)');
                    }
                    
                    console.log('üîç AVANT updateUI() - outputView.innerHTML =', document.getElementById('output-view').innerHTML);
                    
                    // IMPORTANT: Apr√®s runAllThreads(), les statistiques d'ex√©cution ne sont pas track√©es
                    // car cette m√©thode bypass notre syst√®me step-by-step. 
                    // On doit r√©cup√©rer les stats depuis l'interpr√©teur
                    if (interpreter && interpreter.stats) {
                        const stats = interpreter.stats;
                        console.log('üìä R√©cup√©ration des stats depuis l\'interpr√©teur:', stats);
                        
                        // Mettre √† jour executionHistory avec les vraies statistiques
                        executionHistory.clear();
                        if (results.length > 1) {
                            // Mode multi-thread - r√©partir les √©tapes par thread
                            results.forEach((result, index) => {
                                const threadSteps = Math.ceil(stats.totalSteps / results.length);
                                executionHistory.set(result.threadId, threadSteps);
                            });
                        } else {
                            // Mode single-thread
                            executionHistory.set(0, stats.totalSteps);
                        }
                        
                        console.log('üìä executionHistory mis √† jour:', executionHistory);
                        
                        // FORCER la mise √† jour des statistiques - M√âTHODE DIRECTE
                        console.log('üîÑ Injection directe des statistiques');
                        const logElement = document.getElementById('execution-log');
                        if (logElement && stats) {
                            console.log('‚úÖ √âl√©ment trouv√©, injection des statistiques...');
                            const totalSteps = stats.totalSteps;
                            const execTime = (stats.executionEndTime - stats.executionStartTime).toFixed(2);
                            
                            logElement.innerHTML = `
                                <h4>üìä Historique d'ex√©cution</h4>
                                <div style="background: #e8f5e8; padding: 15px; border-radius: 8px; margin: 10px 0; border: 1px solid #4caf50;">
                                    <div style="display: flex; gap: 20px; margin-bottom: 15px;">
                                        <div style="text-align: center;">
                                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Total d'√©tapes</div>
                                            <div style="font-size: 1.3em; font-weight: bold; color: #2196F3;">${totalSteps}</div>
                                        </div>
                                        <div style="text-align: center;">
                                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Temps d'ex√©cution</div>
                                            <div style="font-size: 1.3em; font-weight: bold; color: #2196F3;">${execTime}ms</div>
                                        </div>
                                        <div style="text-align: center;">
                                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Threads actifs</div>
                                            <div style="font-size: 1.3em; font-weight: bold; color: #2196F3;">1</div>
                                        </div>
                                    </div>
                                    <div style="margin-bottom: 10px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                            <span style="font-weight: bold;">Thread T0</span>
                                            <span>${totalSteps} √©tapes (100.0%)</span>
                                        </div>
                                        <div style="background: #ddd; height: 20px; border-radius: 10px; overflow: hidden;">
                                            <div style="background: linear-gradient(90deg, #2196F3, #1976D2); height: 100%; width: 100%; border-radius: 10px;"></div>
                                        </div>
                                    </div>
                                    <div style="font-size: 0.85em; color: #666; margin-top: 10px;">
                                        ‚úÖ Ex√©cution termin√©e avec succ√®s
                                    </div>
                                </div>
                            `;
                            console.log('‚úÖ Statistiques inject√©es directement dans le DOM');
                        } else {
                            console.log('‚ùå Impossible de trouver l\'√©l√©ment execution-log ou les stats');
                        }
                    }
                    
                    updateUI();
                    
                    console.log('‚úÖ Fin de l\'ex√©cution compl√®te avec statistiques inject√©es');
                    console.log('üîç APRES updateUI() - outputView.innerHTML =', document.getElementById('output-view').innerHTML);
                } catch (error) {
                    alert(`‚ùå Erreur d'ex√©cution: ${error.message}`);
                    console.error(error);
                }
            }
        });

        stepBtn.addEventListener('click', () => {
            if (!interpreter || interpreter.getState().halted) initializeInterpreter(); 
            if (interpreter) {
                try {
                    const state = interpreter.getState();
                    
                    // V√©rifier le nombre r√©el de threads dans le gestionnaire
                    const allThreadStates = interpreter.getAllThreadStates();
                    const activeThreads = allThreadStates.filter(t => !t.halted);
                    const hasMultipleThreads = interpreter.hasMultipleActiveThreads();
                    
                    console.log(`üîç Debug step: ${allThreadStates.length} threads total, ${activeThreads.length} actifs, hasMultiple: ${hasMultipleThreads}`);
                    allThreadStates.forEach(t => {
                        console.log(`  T${t.threadId}: IP=${t.ip}/${t.code.length}, halted=${t.halted}, instruction='${t.currentInstruction || 'EOF'}'`);
                    });
                    
                    // Incr√©menter le compteur global
                    globalStepCounter++;
                    const stepNumberEl = document.getElementById('step-number');
                    if (stepNumberEl) stepNumberEl.textContent = globalStepCounter;
                    
                    const stepCounterEl = document.getElementById('step-counter');
                    if (stepCounterEl) stepCounterEl.style.display = 'block';
                    
                    if (hasMultipleThreads) {
                        // Mode multi-thread: ex√©cuter une √©tape pour chaque thread actif
                        const manager = interpreter.threadManager;
                        if (!manager) {
                            console.error('‚ùå Pas de gestionnaire de threads disponible');
                            return;
                        }
                        
                        let anyProgress = false;
                        
                        // Cr√©er un snapshot des threads actifs seulement
                        const activeThreadsSnapshot = Array.from(manager.threads.entries())
                            .filter(([_, thread]) => !thread.halted);
                        
                        console.log(`üîÑ Executing step for ${activeThreadsSnapshot.length} active threads`);
                        
                        for (const [threadId, thread] of activeThreadsSnapshot) {
                            // V√©rifier que le thread existe toujours et est actif
                            if (!manager.threads.has(threadId) || thread.halted) {
                                console.log(`‚ö†Ô∏è Thread T${threadId} d√©j√† supprim√© ou termin√©, ignor√©`);
                                continue;
                            }
                            
                            try {
                                const continued = thread.stepSingleThread();
                                
                                // CORRECTION: Toujours incr√©menter l'historique, m√™me pour la derni√®re √©tape qui termine le thread
                                executionHistory.set(threadId, (executionHistory.get(threadId) || 0) + 1);
                                console.log(`üìä Stats update: Thread T${threadId} now has ${executionHistory.get(threadId)} steps`);
                                
                                console.log(`üîç DEBUG Step result for T${threadId}: continued=${continued}, IP=${thread.ip}/${thread.code.length}, halted=${thread.halted}`);
                                
                                // Correction: Si IP >= code.length, s'assurer que halted = true
                                if (thread.ip >= thread.code.length && !thread.halted) {
                                    console.log(`üîß Thread T${threadId} marqu√© comme termin√© (IP: ${thread.ip}/${thread.code.length})`);
                                    thread.halted = true;
                                }
                                
                                if (continued) {
                                    anyProgress = true;
                                    console.log(`‚ö° T${threadId}: Instruction ex√©cut√©e (IP: ${thread.ip})`);
                                } else {
                                    console.log(`üõë Thread T${threadId} termin√© (IP: ${thread.ip}/${thread.code.length})`);
                                    // CORRECTION: Force halted si continued = false
                                    thread.halted = true;
                                }
                            } catch (error) {
                                console.error(`‚ùå Erreur dans thread T${threadId}:`, error.message);
                                thread.halted = true;
                            }
                            
                            // Capturer les outputs apr√®s chaque step
                            captureThreadOutputs();
                        }
                        
                        // Mettre √† jour l'affichage des statistiques apr√®s chaque cycle
                        generateThreadExecutionLog();
                        
                        // CORRECTION: D√©finir allThreadsHalted au niveau du scope principal
                        const allThreadsHalted = Array.from(manager.threads.values()).every(thread => thread.halted);
                        
                        // INJECTION DIRECTE pour mode multi-thread pas √† pas
                        const logElement = document.getElementById('execution-log');
                        if (logElement && executionHistory.size > 0) {
                            const totalSteps = Array.from(executionHistory.values()).reduce((sum, steps) => sum + steps, 0);
                            const activeThreadsCount = Array.from(manager.threads.values()).filter(t => !t.halted).length;
                            
                            let threadsHtml = '';
                            for (const [threadId, steps] of executionHistory) {
                                const percentage = totalSteps > 0 ? ((steps / totalSteps) * 100).toFixed(1) : 0;
                                const isActive = manager.threads.has(threadId) && !manager.threads.get(threadId).halted;
                                threadsHtml += `
                                    <div style="margin-bottom: 8px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px;">
                                            <span style="font-weight: bold;">Thread T${threadId} ${isActive ? 'üü¢' : 'üî¥'}</span>
                                            <span>${steps} √©tapes (${percentage}%)</span>
                                        </div>
                                        <div style="background: #ddd; height: 12px; border-radius: 6px; overflow: hidden;">
                                            <div style="background: linear-gradient(90deg, #2196F3, #1976D2); height: 100%; width: ${percentage}%; border-radius: 6px; transition: width 0.3s ease;"></div>
                                        </div>
                                    </div>
                                `;
                            }
                            
                            // D√©terminer le message de statut selon l'√©tat des threads (m√™me logique que sortie globale)
                            const statusMessage = allThreadsHalted && manager.threads.size > 0 
                                ? "‚úÖ Tous les threads termin√©s - Ex√©cution compl√®te !" 
                                : "‚è≥ Ex√©cution pas √† pas en cours...";
                            const statusColor = allThreadsHalted ? "#4caf50" : "#666";

                            logElement.innerHTML = `
                                <h4>üìä Historique d'ex√©cution</h4>
                                <div style="background: #f3f4f6; padding: 15px; border-radius: 8px; margin: 10px 0; border: 1px solid #ddd;">
                                    <div style="display: flex; gap: 20px; margin-bottom: 15px;">
                                        <div style="text-align: center;">
                                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Total d'√©tapes</div>
                                            <div style="font-size: 1.3em; font-weight: bold; color: #2196F3;">${totalSteps}</div>
                                        </div>
                                        <div style="text-align: center;">
                                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Threads actifs</div>
                                            <div style="font-size: 1.3em; font-weight: bold; color: #2196F3;">${activeThreadsCount}</div>
                                        </div>
                                        <div style="text-align: center;">
                                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Mode</div>
                                            <div style="font-size: 1.1em; font-weight: bold; color: #ff9800;">Multi-Thread</div>
                                        </div>
                                    </div>
                                    ${threadsHtml}
                                    <div style="font-size: 0.85em; color: ${statusColor}; margin-top: 10px; font-weight: ${allThreadsHalted ? 'bold' : 'normal'};">
                                        ${statusMessage}
                                    </div>
                                </div>
                            `;
                        }
                        
                        // Mettre √† jour l'affichage des threads
                        const remainingActiveThreads = Array.from(manager.threads.values())
                            .filter(thread => !thread.halted);
                        
                        // CORRECTION: allThreadsHalted d√©j√† d√©fini plus haut, pas besoin de red√©clarer
                        
                        console.log(`üîç Threads restants actifs: ${remainingActiveThreads.length}`);
                        console.log(`üîç Total threads dans manager: ${manager.threads.size}`);
                        console.log(`üéØ √âtat unifi√©: allThreadsHalted=${allThreadsHalted}, anyProgress=${anyProgress}`);
                        
                        // Afficher l'√©tat de chaque thread pour debug
                        Array.from(manager.threads.values()).forEach(thread => {
                            console.log(`üîç √âtat Thread T${thread.threadId}: IP=${thread.ip}/${thread.code.length}, halted=${thread.halted}`);
                        });
                        
                        // CORRECTION: En mode Step, ne JAMAIS d√©sactiver automatiquement les boutons
                        // L'utilisateur doit pouvoir continuer √† cliquer m√™me si les threads semblent termin√©s
                        
                        // Afficher un message informatif si tous les threads sont termin√©s, mais ne pas d√©sactiver les boutons
                        if (allThreadsHalted && manager.threads.size > 0) {
                            console.log('‚ÑπÔ∏è Tous les threads termin√©s - Synchronisation des messages');
                            
                            // Ajouter le message de fin dans la sortie globale (une seule fois)
                            const outputView = document.getElementById('output-view');
                            if (outputView && !outputView.innerHTML.includes("termin√©")) {
                                outputView.innerHTML += "\n\n--- ‚úÖ Tous les threads termin√©s ---";
                                console.log("‚úÖ Message 'Threads termin√©s' ajout√© dans sortie globale");
                            }
                            
                            // NE PAS d√©sactiver les boutons en mode Step - l'utilisateur garde le contr√¥le
                        }
                        
                        // Mettre √† jour l'affichage des threads
                        updateMultiThreadView();
                        
                    } else {
                        // Mode single-thread classique
                        const threadId = interpreter.threadId;
                        executionHistory.set(threadId, (executionHistory.get(threadId) || 0) + 1);
                        console.log(`üìä Stats update: Thread T${threadId} now has ${executionHistory.get(threadId)} steps`);
                        
                        interpreter.step();
                        console.log(`‚ö° T${threadId}: ${interpreter.code[interpreter.ip - 1] || 'N/A'} (IP: ${interpreter.ip - 1} ‚Üí ${interpreter.ip})`);
                        
                        // R√©cup√©rer l'√©tat APR√àS l'ex√©cution
                        const currentState = interpreter.getState();
                        console.log(`üìä IP apr√®s step: ${currentState.ip}/${currentState.code.length}`);
                        
                        // Mettre √† jour l'affichage des statistiques - INJECTION DIRECTE
                        const logElement = document.getElementById('execution-log');
                        if (logElement && interpreter.stats) {
                            const stats = interpreter.stats;
                            const totalSteps = executionHistory.get(threadId) || 0;
                            const isTerminated = currentState.halted || currentState.ip >= currentState.code.length;
                            
                            logElement.innerHTML = `
                                <h4>üìä Historique d'ex√©cution</h4>
                                <div style="background: ${isTerminated ? '#e8f5e8' : '#f3f4f6'}; padding: 15px; border-radius: 8px; margin: 10px 0; border: 1px solid ${isTerminated ? '#4caf50' : '#ddd'};">
                                    <div style="display: flex; gap: 20px; margin-bottom: 15px;">
                                        <div style="text-align: center;">
                                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">√âtapes actuelles</div>
                                            <div style="font-size: 1.3em; font-weight: bold; color: #2196F3;">${totalSteps}</div>
                                        </div>
                                        <div style="text-align: center;">
                                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">IP</div>
                                            <div style="font-size: 1.3em; font-weight: bold; color: #2196F3;">${currentState.ip}/${currentState.code.length}</div>
                                        </div>
                                        <div style="text-align: center;">
                                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Mode</div>
                                            <div style="font-size: 1.1em; font-weight: bold; color: #ff9800;">Pas √† Pas</div>
                                        </div>
                                    </div>
                                    <div style="margin-bottom: 10px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                            <span style="font-weight: bold;">Thread T${threadId}</span>
                                            <span>${totalSteps} √©tapes</span>
                                        </div>
                                        <div style="background: #ddd; height: 15px; border-radius: 8px; overflow: hidden;">
                                            <div style="background: linear-gradient(90deg, #2196F3, #1976D2); height: 100%; width: ${Math.min(100, (currentState.ip / Math.max(1, currentState.code.length)) * 100)}%; border-radius: 8px; transition: width 0.3s ease;"></div>
                                        </div>
                                    </div>
                                    <div style="font-size: 0.85em; color: #666; margin-top: 10px;">
                                        ${isTerminated ? '‚úÖ Thread termin√©' : '‚è≥ Ex√©cution en cours...'}
                                    </div>
                                </div>
                            `;
                        }
                        
                        // V√©rifier si le thread unique est termin√© APR√àS l'ex√©cution
                        const state = interpreter.getState();
                        
                        // CORRECTION: V√©rifier aussi si IP >= code.length m√™me si halted pas encore marqu√©
                        if (state.halted || state.ip >= state.code.length) {
                            console.log(`üõë Thread T${threadId} termin√© (IP: ${state.ip}/${state.code.length}, halted: ${state.halted})`);
                            
                            // Forcer halted = true si n√©cessaire
                            if (!state.halted && state.ip >= state.code.length) {
                                interpreter.halted = true;
                                console.log(`üîß Marquage forc√© halted=true pour T${threadId}`);
                            }
                            
                            console.log('üéØ Programme termin√© via step single-thread');
                            
                            // Ajouter le message de fin
                            const outputView = document.getElementById('output-view');
                            if (outputView && !outputView.innerHTML.includes("termin√©")) {
                                outputView.innerHTML += "\n\n\n--- Programme termin√© ---";
                                console.log("‚úÖ Message 'Programme termin√©' ajout√©");
                            }
                            
                            // D√©sactiver les boutons
                            const runAllBtn = document.getElementById('run-all');
                            const stepBtn = document.getElementById('step');
                            if (runAllBtn) {
                                runAllBtn.disabled = true;
                                console.log("üö´ Bouton 'Ex√©cuter' d√©sactiv√©");
                            }
                            if (stepBtn) {
                                stepBtn.disabled = true;
                                console.log("üö´ Bouton 'Step' d√©sactiv√©");
                            }
                        }
                    }
                    
                    // Forcer le nettoyage des threads termin√©s apr√®s chaque step
                    console.log('üßπ Nettoyage forc√© apr√®s step...');
                    if (interpreter) {
                        interpreter.cleanupHaltedThreads();
                    }
                    
                    // Capturer les sorties apr√®s chaque √©tape
                    captureThreadOutputs();
                    
                    updateUI();
                } catch (error) {
                    alert(`‚ùå Erreur d'ex√©cution step: ${error.message}`);
                    console.error(error);
                }
            }
        });

        stepSingleBtn.addEventListener('click', () => {
            if (!interpreter) return;
            
            try {
                const threadId = interpreter.threadId;
                const manager = interpreter.threadManager;
                
                console.log(`üîç AVANT step: Thread T${threadId}, IP=${interpreter.ip}/${interpreter.code.length}, halted=${interpreter.halted}`);
                
                // APPROCHE RADICALE: V√©rifier si on est √† la derni√®re instruction AVANT l'ex√©cution
                const isAtLastInstruction = interpreter.ip >= interpreter.code.length - 1;
                const isAlreadyTerminated = interpreter.halted || interpreter.ip >= interpreter.code.length;
                
                if (isAlreadyTerminated) {
                    console.log(`üö´ Thread T${threadId} d√©j√† termin√© - basculement imm√©diat`);
                    
                    // Marquer comme termin√©
                    interpreter.halted = true;
                    if (manager && manager.threads.has(threadId)) {
                        manager.threads.get(threadId).halted = true;
                    }
                    
                    // Basculer imm√©diatement
                    if (manager) {
                        const activeThreads = Array.from(manager.threads.values())
                            .filter(thread => !thread.halted && thread.threadId !== threadId);
                        
                        if (activeThreads.length > 0) {
                            interpreter = activeThreads[0];
                            console.log(`‚úÖ Basculement imm√©diat vers T${interpreter.threadId}`);
                            updateUI();
                            updateMultiThreadView();
                            return;
                        }
                    }
                    
                    console.log('üéØ Programme termin√©');
                    updateUI();
                    return;
                }
                
                // Le thread est actif, proc√©der √† l'ex√©cution
                console.log(`‚úÖ Thread T${threadId} actif, ex√©cution...`);
                
                globalStepCounter++;
                const stepNumberEl = document.getElementById('step-number');
                if (stepNumberEl) stepNumberEl.textContent = globalStepCounter;
                
                const stepCounterEl = document.getElementById('step-counter');
                if (stepCounterEl) stepCounterEl.style.display = 'block';
                
                if (!threadAccessHistory.includes(threadId)) {
                    threadAccessHistory.push(threadId);
                } else {
                    threadAccessHistory = threadAccessHistory.filter(id => id !== threadId);
                    threadAccessHistory.push(threadId);
                }
                
                executionHistory.set(threadId, (executionHistory.get(threadId) || 0) + 1);
                
                // Ex√©cuter l'√©tape
                const continued = interpreter.stepSingleThread();
                
                console.log(`ÔøΩ APR√àS step: Thread T${threadId}, IP=${interpreter.ip}/${interpreter.code.length}, halted=${interpreter.halted}, continued=${continued}`);
                
                // Si le thread vient de se terminer, basculer IMM√âDIATEMENT
                if (!continued || interpreter.halted || interpreter.ip >= interpreter.code.length) {
                    console.log(`üõë Thread T${threadId} termin√© - basculement imm√©diat post-step`);
                    
                    // Forcer le marquage
                    interpreter.halted = true;
                    if (manager && manager.threads.has(threadId)) {
                        manager.threads.get(threadId).halted = true;
                    }
                    
                    // Basculer vers un thread actif
                    if (manager) {
                        const activeThreads = Array.from(manager.threads.values())
                            .filter(thread => !thread.halted && thread.threadId !== threadId);
                        
                        console.log(`üîç Threads actifs disponibles: ${activeThreads.length}`);
                        
                        if (activeThreads.length > 0) {
                            // Prioriser l'historique
                            let nextThread = null;
                            for (let i = threadAccessHistory.length - 1; i >= 0; i--) {
                                const historyThreadId = threadAccessHistory[i];
                                const candidateThread = activeThreads.find(t => t.threadId === historyThreadId);
                                if (candidateThread) {
                                    nextThread = candidateThread;
                                    break;
                                }
                            }
                            
                            if (!nextThread) {
                                nextThread = activeThreads[0];
                            }
                            
                            interpreter = nextThread;
                            console.log(`‚úÖ Basculement post-step vers T${nextThread.threadId}`);
                            
                            captureThreadOutputs();
                            updateUI();
                            updateMultiThreadView();
                            return;
                        } else {
                            console.log('üéØ Aucun thread actif - programme termin√©');
                            const stepCounterEl = document.getElementById('step-counter');
                            if (stepCounterEl) stepCounterEl.style.display = 'none';
                        }
                    }
                }
                
                // Thread continue normalement - mise √† jour standard
                console.log(`‚úÖ Thread T${threadId} continue normalement`);
                captureThreadOutputs();
                updateUI();
                updateMultiThreadView();
                
            } catch (error) {
                alert(`‚ùå Erreur d'ex√©cution step single: ${error.message}`);
                console.error(error);
            }
        });

        switchThreadBtn.addEventListener('click', () => {
            if (!interpreter || !interpreter.threadManager) return;
            
            const manager = interpreter.threadManager;
            const activeThreads = [];
            
            // CORRECTION: Utiliser directement le gestionnaire pour plus de fiabilit√©
            for (const [threadId, thread] of manager.threads) {
                if (!thread.halted) {
                    activeThreads.push(thread);
                }
            }
            
            if (activeThreads.length > 1) {
                const currentIndex = activeThreads.findIndex(t => t.threadId === interpreter.threadId);
                const nextIndex = (currentIndex + 1) % activeThreads.length;
                const nextThread = activeThreads[nextIndex];
                
                interpreter = nextThread;
                console.log(`üîÑ Thread actuel chang√© vers T${nextThread.threadId}`);
                
                // Enregistrer l'acc√®s manuel dans l'historique
                if (!threadAccessHistory.includes(nextThread.threadId)) {
                    threadAccessHistory.push(nextThread.threadId);
                } else {
                    threadAccessHistory = threadAccessHistory.filter(id => id !== nextThread.threadId);
                    threadAccessHistory.push(nextThread.threadId);
                }
                
                updateUI();
                updateMultiThreadView();
            } else if (activeThreads.length === 1 && activeThreads[0].threadId !== interpreter.threadId) {
                // Cas o√π le thread actuel est termin√© mais il reste un thread actif
                interpreter = activeThreads[0];
                console.log(`üîÑ Basculement vers le dernier thread actif T${activeThreads[0].threadId}`);
                
                // Enregistrer l'acc√®s dans l'historique
                if (!threadAccessHistory.includes(activeThreads[0].threadId)) {
                    threadAccessHistory.push(activeThreads[0].threadId);
                } else {
                    threadAccessHistory = threadAccessHistory.filter(id => id !== activeThreads[0].threadId);
                    threadAccessHistory.push(activeThreads[0].threadId);
                }
                
                updateUI();
                updateMultiThreadView();
            }
        });

        resetBtn.addEventListener('click', () => {
            // R√©initialisation compl√®te - le gestionnaire de threads sera recr√©√© avec la nouvelle instance
            
            // Reset des compteurs et donn√©es
            globalStepCounter = 0;
            executionHistory.clear();
            threadInputData.clear();
            threadAccessHistory = []; // Reset de l'historique des threads
            
            // Reset s√©curis√© des √©l√©ments DOM
            const stepNumberEl = document.getElementById('step-number');
            if (stepNumberEl) stepNumberEl.textContent = '0';
            
            const stepCounterEl = document.getElementById('step-counter');
            if (stepCounterEl) stepCounterEl.style.display = 'none';
            
            // Nettoyer l'interface
            const outputEl = document.querySelector('#output pre');
            if (outputEl) outputEl.textContent = '';
            
            const memoryViewEl = document.getElementById('memory-view');
            if (memoryViewEl) memoryViewEl.innerHTML = '';
            
            const executionLogEl = document.getElementById('execution-log');
            if (executionLogEl) {
                executionLogEl.innerHTML = `
                    <h4>üìä Historique d'ex√©cution</h4>
                    <p style="color: #666; font-style: italic;">Aucune ex√©cution pour le moment - Lancez un programme pour voir les statistiques !</p>
                `;
            }
            
            // Remettre les zones I/O en mode single-thread
            document.getElementById('single-thread-input').style.display = 'block';
            document.getElementById('multi-thread-inputs').style.display = 'none';
            document.getElementById('multi-thread-view').style.display = 'none';
            document.getElementById('output-legend').style.display = 'none';
            
            // R√©afficher l'√©tat single-thread
            document.getElementById('single-thread-state').style.display = 'block';
            
            console.clear();
            console.log('üîÑ Interpr√©teur r√©initialis√©');
            
            initializeInterpreter();
            
            // Restaurer l'affichage initial des statistiques
            generateThreadExecutionLog();
        });

        // Gestionnaire pour la limite de threads
        document.getElementById('max-threads').addEventListener('change', (e) => {
            const newLimit = parseInt(e.target.value);
            if (newLimit > 0 && interpreter) {
                interpreter.setMaxThreads(newLimit);
                console.log(`Limite de threads mise √† jour: ${newLimit}`);
            }
        });

        // Variable pour contr√¥ler la vue d√©taill√©e des threads
        let showDetailedThreadView = true;
        let globalStepCounter = 0;
        let executionHistory = new Map(); // Historique d'ex√©cution par thread
        let threadInputData = new Map(); // Donn√©es d'entr√©e par thread
        let threadAccessHistory = []; // Historique des threads utilis√©s (pour priorit√© de retour)
        
        // Informations de version de l'application
        const APP_VERSION = '1.12.0';
        const BUILD_DATE = '2025-10-03';
        
        // Gestionnaire pour le bouton de bascule de vue
        document.getElementById('toggle-thread-details').addEventListener('click', () => {
            showDetailedThreadView = !showDetailedThreadView;
            const button = document.getElementById('toggle-thread-details');
            button.textContent = showDetailedThreadView ? 'üëÅÔ∏è Vue Compacte' : 'üëÅÔ∏è Vue D√©taill√©e';
            
            // Mettre √† jour l'affichage imm√©diatement
            if (interpreter && interpreter.getState().totalThreads > 1) {
                updateMultiThreadView();
            }
        });

        // Initialisation apr√®s le chargement complet
        window.addEventListener('load', () => {
            if (typeof BrainfuckInterpreter === 'undefined') {
                alert("Erreur: Le fichier 'BrainfuckInterpreter.js' n'a pas √©t√© trouv√© ou charg√© correctement. V√©rifiez le chemin.");
            } else {
                // Initialiser le bouton de vue
                const toggleButton = document.getElementById('toggle-thread-details');
                toggleButton.textContent = showDetailedThreadView ? 'üëÅÔ∏è Vue Compacte' : 'üëÅÔ∏è Vue D√©taill√©e';
                
                initializeInterpreter();
                
                // FORCE l'affichage initial des statistiques pour debug
                setTimeout(() => {
                    console.log('üîç Force update statistics display');
                    generateThreadExecutionLog();
                    
                    // Test: ajouter des donn√©es fictives pour v√©rifier l'affichage
                    executionHistory.set(0, 5);
                    executionHistory.set(1, 3);
                    console.log('üß™ Added test data to executionHistory:', executionHistory);
                    generateThreadExecutionLog();
                }, 1000);
            }
        });

    </script>
    
    <!-- Pied de page avec num√©ro de version -->
    <footer style="margin-top: 50px; padding: 20px 0; border-top: 1px solid #eee; text-align: center; color: #999; font-size: 12px;">
        <div id="version-info">
            üß† ForkBrain - Where Brainfuck meets Unix threading !
            <br>
            <span style="font-family: monospace;">Version <span id="app-version">1.12.0</span> ‚Ä¢ Build <span id="build-date">2025-10-03</span></span>
            <br>
            <a href="https://github.com/vfarcy/brainfuck" style="color: #666; text-decoration: none;" target="_blank">
                üì¶ Code source sur GitHub
            </a>
        </div>
    </footer>
</body>
</html>
