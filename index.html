<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🧠 BrainJS: Interpréteur Brainfuck</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }
        h1, h2 {
            color: #333;
        }
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
        }
        .editor-wrapper {
            position: relative;
            width: 100%;
            margin-top: 8px;
            margin-bottom: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
            overflow: hidden;
            display: grid; /* Utiliser grid pour superposer les éléments */
        }
        .editor-wrapper textarea,
        .editor-wrapper pre {
            grid-area: 1 / 1 / 2 / 2; /* Placer les deux dans la même cellule de la grille */
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
            tab-size: 2;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .editor-wrapper pre {
            pointer-events: none;
            background-color: #fff;
        }
        .editor-wrapper textarea { 
            z-index: 1;
            border: none;
            background-color: transparent;
            color: transparent;
            caret-color: #222;
            resize: vertical;
            -webkit-text-fill-color: transparent;
        }
        .editor-wrapper textarea:focus {
            outline: none;
        }
        .code-editor::selection {
            background-color: rgba(33, 150, 243, 0.35);
        }
        .bf-token {
            display: inline;
            color: #444;
        }
        .bf-comment {
            color: #bdbdbd;
        }
        .bf-move-right,
        .bf-move-left {
            color: #1565c0;
        }
        .bf-increment,
        .bf-decrement {
            color: #2e7d32;
        }
        .bf-output {
            color: #ef6c00;
        }
        .bf-input {
            color: #8e24aa;
        }
        .bf-loop-start,
        .bf-loop-end {
            color: #d81b60;
        }
        .bf-fork {
            color: #ff6b35;
            font-weight: bold;
        }
        .bf-active {
            background-color: #ff9900;
            color: #fff !important;
            border-radius: 3px;
            padding: 0 2px;
        }
        button {
            padding: 10px 15px;
            margin-right: 10px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        #run-all { background-color: #4CAF50; color: white; }
        #run-all:hover:not(:disabled) { background-color: #45a049; }
        #step-btn { background-color: #2196F3; color: white; }
        #step-btn:hover:not(:disabled) { background-color: #0b7dda; }
        #reset-btn { background-color: #f44336; color: white; }
        #reset-btn:hover:not(:disabled) { background-color: #da190b; }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        /* --- Styles de Sortie et Mémoire --- */
        #output-view, #code-view {
            white-space: normal;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #fff;
            min-height: 50px;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
            overflow: auto;
        }
        #memory-view {
            max-width: 100%;
        }
        .memory-scroll-wrapper {
            width: 100%;
            max-width: 100%;
        }
        .memory-scroll {
            overflow-x: auto;
            overflow-y: hidden;
            padding-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
        }
        .memory-scroll::-webkit-scrollbar {
            height: 8px;
        }
        .memory-scroll::-webkit-scrollbar-thumb {
            background-color: rgba(0,0,0,0.25);
            border-radius: 4px;
        }
        .memory-scroll::-webkit-scrollbar-track {
            background-color: rgba(0,0,0,0.05);
        }
        .memory-scroll table {
            border-collapse: collapse;
            font-size: 14px;
            min-width: 500px;
            width: max-content;
        }
        .memory-scroll td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
            white-space: nowrap;
        }
        .memory-scroll-slider {
            width: 100%;
            margin-top: 6px;
            appearance: none;
            height: 6px;
            border-radius: 4px;
            background: #d0d0d0;
            cursor: pointer;
        }
        .memory-scroll-slider:focus {
            outline: 2px solid rgba(33, 150, 243, 0.4);
            outline-offset: 2px;
        }
        .memory-scroll-slider::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2196F3;
            border: none;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
        }
        .memory-scroll-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2196F3;
            border: none;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
        }
        .header-row td {
            font-weight: bold;
            background-color: #f0f0f0;
            color: #555;
        }
        .active-cell {
            background-color: #ff9900 !important;
            color: white;
            font-weight: bold;
            border-color: #cc7a00 !important;
        }
        .ellipsis-cell {
            font-weight: bold;
            color: #999;
        }
        
        /* Styles pour le multithreading */
        #thread-info {
            background: linear-gradient(135deg, #e3f2fd, #f0f8ff);
            border: 2px solid #4a90e2;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        #multi-thread-view {
            margin-top: 20px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 12px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        
        .thread-state {
            background: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            transition: all 0.3s ease;
        }
        
        .thread-state:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .thread-state.active {
            border-left: 5px solid #4caf50;
            background: #f8fff8;
        }
        
        .thread-state.halted {
            border-left: 5px solid #f44336;
            background: #fff8f8;
        }
        
        .thread-state.current {
            border: 2px solid #2196F3;
            background: #e3f2fd;
        }
        
        .thread-execution-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4caf50;
            animation: pulse 1s infinite;
        }
        
        .thread-execution-indicator.executing {
            background: #ff9900;
            animation: flash 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        @keyframes flash {
            0% { background: #ff9900; transform: scale(1); }
            50% { background: #ffeb3b; transform: scale(1.2); }
            100% { background: #ff9900; transform: scale(1); }
        }
        
        .thread-timeline {
            margin-top: 10px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .step-counter {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #2196F3;
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .thread-progress-bar {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .thread-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        .execution-log {
            max-height: 100px;
            overflow-y: auto;
            font-size: 10px;
            background: #fafafa;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            padding: 5px;
            margin-top: 5px;
        }
        
        .thread-header {
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .thread-details {
            color: #666;
            line-height: 1.4;
        }
        
        .thread-memory {
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 8px;
        }
        
        .thread-memory-scroll {
            overflow-x: auto;
            max-width: 100%;
            margin-top: 5px;
        }
        
        .thread-memory table {
            border-collapse: collapse;
            font-size: 11px;
            min-width: 300px;
        }
        
        .thread-memory td {
            border: 1px solid #ddd;
            padding: 4px 6px;
            text-align: center;
            white-space: nowrap;
        }
        
        .thread-memory .header-row td {
            font-weight: bold;
            background-color: #f0f0f0;
            color: #555;
            font-size: 10px;
        }
        
        .thread-memory .active-cell {
            background-color: #ff9900 !important;
            color: white;
            font-weight: bold;
            border-color: #cc7a00 !important;
        }
        
        .thread-code {
            margin-top: 8px;
            padding: 6px;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 11px;
            max-height: 60px;
            overflow-y: auto;
        }
        
        #max-threads-control {
            margin: 10px 0;
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
        }
        
        .warning-text {
            color: #856404;
            font-size: 12px;
            margin-top: 5px;
        }
            /* Logs d'exécution */
        .execution-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #2196F3;
        }

        .thread-logs {
            margin-top: 15px;
        }

        .thread-log-item {
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            background: #fff;
        }

        .thread-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .thread-id {
            font-weight: bold;
            color: #333;
        }

        .thread-steps {
            font-size: 0.9em;
            color: #666;
        }

        .thread-progress-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }

        .thread-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #2196F3);
            transition: width 0.3s ease;
        }

        /* Styles pour les zones d'entrée/sortie par thread */
        .thread-io {
            margin-top: 10px;
            padding: 8px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        
        .thread-io-section {
            margin-bottom: 8px;
        }
        
        .thread-io-label {
            font-weight: bold;
            font-size: 11px;
            color: #555;
            margin-bottom: 3px;
            display: block;
        }
        
        .thread-input {
            width: 100%;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-family: monospace;
            font-size: 11px;
            resize: none;
            height: 40px;
            box-sizing: border-box;
        }
        
        .thread-output {
            width: 100%;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-family: monospace;
            font-size: 11px;
            background: #fff;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 60px;
            overflow-y: auto;
            min-height: 40px;
            box-sizing: border-box;
        }
        
        .thread-output:empty:before {
            content: "Aucune sortie...";
            color: #999;
            font-style: italic;
        }
        
        .thread-io-compact {
            display: flex;
            gap: 10px;
        }
        
        .thread-io-compact .thread-io-section {
            flex: 1;
            margin-bottom: 0;
        }

        /* Styles pour les zones d'entrée par thread en mode multi-thread */
        .multi-thread-input {
            margin-bottom: 10px;
            padding: 8px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        
        .multi-thread-input-label {
            font-weight: bold;
            font-size: 12px;
            color: #555;
            margin-bottom: 5px;
            display: block;
        }
        
        .multi-thread-input textarea {
            width: 100%;
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
            height: 50px;
            box-sizing: border-box;
        }

        /* Couleurs pour identifier les threads dans la sortie */
        #output-view .thread-output-T0 { color: #2196F3 !important; font-weight: bold !important; }
        #output-view .thread-output-T1 { color: #4CAF50 !important; font-weight: bold !important; }
        #output-view .thread-output-T2 { color: #FF9800 !important; font-weight: bold !important; }
        #output-view .thread-output-T3 { color: #9C27B0 !important; font-weight: bold !important; }
        #output-view .thread-output-T4 { color: #F44336 !important; font-weight: bold !important; }
        #output-view .thread-output-T5 { color: #795548 !important; font-weight: bold !important; }
        #output-view .thread-output-T6 { color: #607D8B !important; font-weight: bold !important; }
        #output-view .thread-output-T7 { color: #E91E63 !important; font-weight: bold !important; }
        
        /* Style pour les caractères non-imprimables en hexa */
        .hex-char {
            background: #f0f0f0;
            padding: 1px 3px;
            border-radius: 2px;
            font-size: 0.9em;
            color: #666;
            font-family: 'Courier New', monospace;
            border: 1px solid #ddd;
            margin: 0 1px;
        }
        
        .hex-char:hover {
            background: #e0e0e0;
            border-color: #bbb;
        }
        
        /* Couleurs des threads pour les caractères hexadécimaux */
        #output-view .thread-output-T0 .hex-char { border-color: #2196F3 !important; background: #e3f2fd !important; color: #1565c0 !important; }
        #output-view .thread-output-T1 .hex-char { border-color: #4CAF50 !important; background: #e8f5e8 !important; color: #2e7d32 !important; }
        #output-view .thread-output-T2 .hex-char { border-color: #FF9800 !important; background: #fff3e0 !important; color: #ef6c00 !important; }
        #output-view .thread-output-T3 .hex-char { border-color: #9C27B0 !important; background: #f3e5f5 !important; color: #7b1fa2 !important; }
        #output-view .thread-output-T4 .hex-char { border-color: #F44336 !important; background: #ffebee !important; color: #d32f2f !important; }
        #output-view .thread-output-T5 .hex-char { border-color: #795548 !important; background: #efebe9 !important; color: #5d4037 !important; }
        #output-view .thread-output-T6 .hex-char { border-color: #607D8B !important; background: #eceff1 !important; color: #455a64 !important; }
        #output-view .thread-output-T7 .hex-char { border-color: #E91E63 !important; background: #fce4ec !important; color: #c2185b !important; }
        
        /* Effet hover pour les hex-char colorés */
        .thread-output-T0 .hex-char:hover { background: #bbdefb; }
        .thread-output-T1 .hex-char:hover { background: #c8e6c9; }
        .thread-output-T2 .hex-char:hover { background: #ffe0b2; }
        .thread-output-T3 .hex-char:hover { background: #e1bee7; }
        .thread-output-T4 .hex-char:hover { background: #ffcdd2; }
        .thread-output-T5 .hex-char:hover { background: #d7ccc8; }
        .thread-output-T6 .hex-char:hover { background: #cfd8dc; }
        .thread-output-T7 .hex-char:hover { background: #f8bbd9; }
        
        /* Styles pour les caractères texte colorés par thread */
        .thread-char-T0 { color: #2196F3; font-weight: bold; }
        .thread-char-T1 { color: #4CAF50; font-weight: bold; }
        .thread-char-T2 { color: #FF9800; font-weight: bold; }
        .thread-char-T3 { color: #9C27B0; font-weight: bold; }
        .thread-char-T4 { color: #F44336; font-weight: bold; }
        .thread-char-T5 { color: #795548; font-weight: bold; }
        .thread-char-T6 { color: #607D8B; font-weight: bold; }
        .thread-char-T7 { color: #E91E63; font-weight: bold; }
        
        /* Styles pour les caractères hexadécimaux colorés par thread */
        .thread-hex-T0 { border-color: #2196F3; background: #e3f2fd; color: #1565c0; }
        .thread-hex-T1 { border-color: #4CAF50; background: #e8f5e8; color: #2e7d32; }
        .thread-hex-T2 { border-color: #FF9800; background: #fff3e0; color: #ef6c00; }
        .thread-hex-T3 { border-color: #9C27B0; background: #f3e5f5; color: #7b1fa2; }
        .thread-hex-T4 { border-color: #F44336; background: #ffebee; color: #d32f2f; }
        .thread-hex-T5 { border-color: #795548; background: #efebe9; color: #5d4037; }
        .thread-hex-T6 { border-color: #607D8B; background: #eceff1; color: #455a64; }
        .thread-hex-T7 { border-color: #E91E63; background: #fce4ec; color: #c2185b; }
        
        /* Légende des couleurs de threads */
        .thread-legend-item {
            display: inline-block;
            margin-right: 15px;
            font-size: 12px;
        }
        
        .thread-legend-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 5px;
            vertical-align: middle;
        }

        </style>
</head>
<body>

    <h1>🧠 BrainJS: Interpréteur Brainfuck</h1>

    <label for="bf-code">Entrez votre programme Brainfuck :</label>
    <div class="editor-wrapper">
        <pre id="code-highlight" aria-hidden="true"></pre>
        <textarea id="bf-code" class="code-editor" rows="10" cols="80">++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.

// Exemples avec fork (commande 'f'):
// Simple: ++f    (Parent: cell[0]=0, Enfant: cell[1]=1)
// Test: +++f>+++f>+++
// ⚠️ Danger: +[f+]  (Explosion de threads!)</textarea>
    </div>
    
    <p>
        <button id="run-all" aria-label="Exécuter d'un coup">▶ Exécuter D'un Coup</button>
        <button id="step-btn" aria-label="Exécuter pas à pas">👣 Step (Tous Threads)</button>
        <button id="step-single-btn" aria-label="Exécuter pas à pas thread unique" style="display: none;">👤 Step (Thread Actuel)</button>
        <button id="reset-btn" aria-label="Réinitialiser">🔄 Réinitialiser</button>
    </p>
    
    <!-- Contrôle pour la limite de threads -->
    <div id="max-threads-control">
        <label for="max-threads">🛡️ Limite max de threads:</label>
        <input type="number" id="max-threads" value="8" min="1" max="1000" style="width: 80px;">
        <div class="warning-text">
            ⚠️ Attention: La commande 'f' peut créer des explosions de threads (ex: "+[f+]"). Limite globale de sécurité.
        </div>
    </div>
    
    <!-- Compteur d'étapes global -->
    <div id="step-counter" class="step-counter" style="display: none;">
        Étape: <span id="step-number">0</span>
    </div>

    <hr>
    
    <!-- Section d'information des threads -->
    <div id="thread-info">
        <strong>🔗 Thread Principal (T0)</strong> - Aucun fork détecté
    </div>
    
    <!-- Vue multi-thread (masquée par défaut) -->
    <div id="multi-thread-view" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">🔀 État de Tous les Threads Actifs</h3>
            <button id="toggle-thread-details" style="padding: 5px 10px; font-size: 12px;">
                👁️ Vue Détaillée
            </button>
        </div>
        <div id="threads-container">
            <!-- Les threads s'afficheront ici dynamiquement -->
        </div>
    </div>
    
    <!-- Historique d'exécution -->
    <div id="execution-log" style="margin-top: 20px;">
        <!-- L'historique d'exécution s'affichera ici -->
    </div>
    
    <!-- Zones d'entrée/sortie globales -->
    <div id="global-io">
        <h2>📥 Données d'Entrée (Input)</h2>
        <div id="input-section">
            <!-- Zone d'entrée globale pour le mode single-thread -->
            <div id="single-thread-input" style="display: block;">
                <textarea id="bf-input" rows="3" cols="80" placeholder="Entrez les données lues par la commande ',' (virgule) ici. Par exemple: 'Hello'"></textarea>
            </div>
            
            <!-- Zones d'entrée par thread pour le mode multi-thread -->
            <div id="multi-thread-inputs" style="display: none;">
                <!-- Les zones d'entrée par thread s'afficheront ici -->
            </div>
        </div>

        <h2>📤 Sortie (Output) - Globale Unifiée</h2>
        <pre id="output-view">En attente d'exécution...</pre>
        
        <!-- Légende des threads dans la sortie (visible uniquement en mode multi-thread) -->
        <div id="output-legend" style="display: none; margin-top: 10px; padding: 8px; background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 4px;">
            <strong>🏷️ Légende des Threads:</strong>
            <div id="thread-colors-legend"></div>
        </div>
    </div>

    <hr>

    <!-- État de l'interpréteur (visible uniquement en mode single-thread) -->
    <div id="single-thread-state">
        <h2>État de l'Interpréteur</h2>
        <p>
            Pointeur d'Instruction (IP): <span id="ip-view">0</span>
            &nbsp;|&nbsp;
            Pointeur de Cellule (PTR): <span id="ptr-view">0</span>
        </p>

        <h3>Code en cours d'exécution</h3>
        <pre id="code-view"></pre>

        <h3>Mémoire (Cellules autour du PTR)</h3>
        <div id="memory-view"></div>
    </div>

    <script src="BrainfuckInterpreter.js?v=1.3.0"></script> 

    <script>
        // Vérification du chargement de BrainfuckInterpreter
        if (typeof BrainfuckInterpreter === 'undefined') {
            console.error('❌ BrainfuckInterpreter non chargé !');
            alert('Erreur: Le fichier BrainfuckInterpreter.js n\'a pas pu être chargé. Vérifiez votre connexion internet ou rechargez la page.');
        } else {
            console.log('✅ BrainfuckInterpreter chargé avec succès');
            
            // Vérification des méthodes critiques
            const requiredMethods = ['cleanupHaltedThreads', 'debugThreadManager', 'getAllThreadStates'];
            const missingMethods = requiredMethods.filter(method => typeof BrainfuckInterpreter[method] !== 'function');
            
            if (missingMethods.length > 0) {
                console.warn('⚠️ Méthodes manquantes:', missingMethods);
            } else {
                console.log('✅ Toutes les méthodes critiques sont disponibles');
            }
        }

        let interpreter = null;
        
        // Cache des sorties des threads pour la coloration
        let threadOutputsCache = new Map();

        // Références DOM
        const codeInput = document.getElementById('bf-code');
        const inputData = document.getElementById('bf-input');
        const outputView = document.getElementById('output-view');
        const ipView = document.getElementById('ip-view');
        const ptrView = document.getElementById('ptr-view');
        const memoryView = document.getElementById('memory-view');
        const codeView = document.getElementById('code-view');
        const codeHighlight = document.getElementById('code-highlight');
        const runAllBtn = document.getElementById('run-all');
        const stepBtn = document.getElementById('step-btn');
        const stepSingleBtn = document.getElementById('step-single-btn');
        const resetBtn = document.getElementById('reset-btn');

        const BF_TOKEN_CLASSES = {
            '>': 'bf-move-right',
            '<': 'bf-move-left',
            '+': 'bf-increment',
            '-': 'bf-decrement',
            '.': 'bf-output',
            ',': 'bf-input',
            '[': 'bf-loop-start',
            ']': 'bf-loop-end',
            'f': 'bf-fork'
        };

        function escapeHtml(text) {
            return text.replace(/[&<>"']/g, (char) => {
                switch (char) {
                    case '&': return '&amp;';
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '"': return '&quot;';
                    case "'": return '&#39;';
                    default: return char;
                }
            });
        }

        function buildHighlightedHtml(source, activeIndex = null) {
            if (!source) return '';
            let html = '';
            for (let i = 0; i < source.length; i++) {
                const char = source[i];
                if (char === '\n') {
                    html += '\n';
                    continue;
                }
                const classes = ['bf-token'];
                const tokenClass = BF_TOKEN_CLASSES[char] || 'bf-comment';
                classes.push(tokenClass);
                if (activeIndex !== null && i === activeIndex) {
                    classes.push('bf-active');
                }
                html += `<span class="${classes.join(' ')}">${escapeHtml(char)}</span>`;
            }
            return html;
        }

        function renderEditorHighlight(activeOriginalIndex = null) {
            codeHighlight.innerHTML = buildHighlightedHtml(codeInput.value, activeOriginalIndex);
            syncHighlightScroll();
        }

        function syncHighlightScroll() {
            codeHighlight.style.transform = `translate(${-codeInput.scrollLeft}px, ${-codeInput.scrollTop}px)`;
            // La transformation est plus fluide si elle est dans une frame d'animation
            requestAnimationFrame(() => {
                codeHighlight.style.transform = `translate(${-codeInput.scrollLeft}px, ${-codeInput.scrollTop}px)`;
            });
        }

        function setupMemoryScrollbar(wrapper) {
            if (!wrapper) return;

            const scrollContainer = wrapper.querySelector('.memory-scroll');
            const slider = wrapper.querySelector('.memory-scroll-slider');

            if (!scrollContainer || !slider) return;

            const updateSlider = () => {
                const overflow = scrollContainer.scrollWidth - scrollContainer.clientWidth;
                if (overflow > 0.5) {
                    slider.style.display = 'block';
                    slider.max = overflow;
                    slider.value = Math.min(scrollContainer.scrollLeft, overflow);
                } else {
                    slider.style.display = 'none';
                    slider.value = 0;
                    scrollContainer.scrollLeft = 0;
                }
            };

            slider.addEventListener('input', () => {
                scrollContainer.scrollLeft = Number(slider.value);
            });

            scrollContainer.addEventListener('scroll', () => {
                slider.value = scrollContainer.scrollLeft;
            });

            requestAnimationFrame(updateSlider);
        }

        codeInput.addEventListener('input', () => {
            renderEditorHighlight();
        });

        codeInput.addEventListener('scroll', () => {
            syncHighlightScroll();
        });
        
        window.addEventListener('resize', () => {
            syncHighlightScroll();
            if (interpreter) {
                updateUI();
            }
        });

        // Première coloration au chargement du script
        renderEditorHighlight();
        
        /**
         * Initialise ou réinitialise l'interpréteur avec le code et les données d'entrée.
         */
        function initializeInterpreter() {
            try {
                // Vérifier que la classe BrainfuckInterpreter est chargée
                if (typeof BrainfuckInterpreter === 'undefined') {
                    throw new Error('BrainfuckInterpreter non chargé');
                }
                
                // Le gestionnaire de threads est automatiquement initialisé par chaque nouvelle instance
                
                // Réinitialiser le cache des sorties
                threadOutputsCache.clear();
                console.log('🧹 Cache des sorties vidé');
                
                // Passage du code et des données d'entrée globales pour le thread principal
                const globalInput = inputData.value;
                interpreter = new BrainfuckInterpreter(codeInput.value, globalInput); 
                
                // Initialiser les données d'entrée pour le thread principal (T0)
                threadInputData.set(0, globalInput);
                
                // Appliquer la limite de threads depuis l'interface
                const maxThreadsInput = document.getElementById('max-threads');
                if (maxThreadsInput && interpreter) {
                    interpreter.setMaxThreads(parseInt(maxThreadsInput.value));
                }
                
                // Debug initial
                if (typeof BrainfuckInterpreter.debugThreadManager === 'function') {
                    BrainfuckInterpreter.debugThreadManager();
                }
                
                updateUI();
                runAllBtn.disabled = false;
                stepBtn.disabled = false;
                outputView.innerHTML = '<span style="color: #999; font-style: italic;">Programme réinitialisé - Prêt pour l\'exécution</span>';
            } catch (error) {
                alert("Erreur de syntaxe Brainfuck: " + error.message);
                interpreter = null;
            }
        }

        /**
         * Formate la valeur d'une cellule mémoire pour l'affichage.
         * Si la valeur correspond à un caractère ASCII imprimable, l'affiche.
         * @param {number} value La valeur numérique de la cellule.
         * @returns {string} La valeur formatée en HTML.
         */
        function formatMemoryCell(value) {
            const hexValue = '0x' + value.toString(16).toUpperCase().padStart(2, '0');

            // Les caractères imprimables ASCII sont généralement entre 32 (espace) et 126 (~)
            if (value >= 32 && value <= 126) {
                const char = escapeHtml(String.fromCharCode(value));
                return `${hexValue} <span style="color: #aaa; font-weight: bold;">'<span style="color: #0b7dda;">${char}</span>'</span>`;
            }
            // Pour les autres valeurs (non imprimables, null, etc.), on affiche juste le nombre.
            return hexValue;
        }

        /**
         * Génère les logs d'exécution des threads
         */
        function generateThreadExecutionLog() {
            const logElement = document.getElementById('execution-log');
            if (!logElement) return;
            
            let html = '<h4>📊 Historique d\'exécution</h4>';
            
            if (executionHistory.size === 0) {
                html += '<p style="color: #666; font-style: italic;">Aucune exécution pour le moment</p>';
            } else {
                html += '<div class="execution-stats">';
                
                // Statistiques globales
                const totalSteps = Array.from(executionHistory.values()).reduce((sum, steps) => sum + steps, 0);
                html += `<div class="stat-item">
                    <span class="stat-label">Total d'étapes:</span>
                    <span class="stat-value">${totalSteps}</span>
                </div>`;
                
                html += `<div class="stat-item">
                    <span class="stat-label">Threads actifs:</span>
                    <span class="stat-value">${executionHistory.size}</span>
                </div>`;
                
                html += '</div>';
                
                // Détails par thread
                html += '<div class="thread-logs">';
                for (const [threadId, steps] of executionHistory) {
                    const percentage = totalSteps > 0 ? ((steps / totalSteps) * 100).toFixed(1) : 0;
                    html += `
                        <div class="thread-log-item">
                            <div class="thread-log-header">
                                <span class="thread-id">Thread T${threadId}</span>
                                <span class="thread-steps">${steps} étapes (${percentage}%)</span>
                            </div>
                            <div class="thread-progress-bar">
                                <div class="thread-progress-fill" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    `;
                }
                html += '</div>';
            }
            
            logElement.innerHTML = html;
        }

        /**
         * Met à jour tous les éléments de l'interface utilisateur.
         */
        function updateUI() {
            if (!interpreter) return;

            const state = interpreter.getState();

            // 1. Mise à jour des compteurs et sortie avec annotations de threads
            updateGlobalOutput();
            ipView.textContent = state.ip;
            ptrView.textContent = state.ptr;

            // 2. Visualisation du code et du Pointeur d'Instruction (IP)
            
            const activeInstructionIndex = state.code.length === 0
                ? null
                : (state.ip < state.code.length ? state.ip : state.code.length - 1);
            const activeOriginalIndex = (!state.codeMap || state.codeMap.length === 0)
                ? null
                : (state.ip < state.codeMap.length ? state.codeMap[state.ip] : state.codeMap[state.codeMap.length - 1]);

            codeView.innerHTML = buildHighlightedHtml(state.code, activeInstructionIndex);
            renderEditorHighlight(activeOriginalIndex);


            // 3. Visualisation de la mémoire et du Pointeur de Cellule (PTR)
            let memDisplay = '<table>';
            const windowRadius = 7;
            const memoryLength = state.memoryFull.length;
            const start = Math.max(0, state.ptr - windowRadius);
            const end = Math.min(state.ptr + windowRadius + 1, memoryLength);

            // Ligne 1: Index (PTR)
            memDisplay += '<tr class="header-row">';
            if (start > 0) {
                memDisplay += '<td class="ellipsis-cell">…</td>';
            }
            for (let i = start; i < end; i++) {
                memDisplay += `<td>${i}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td class="ellipsis-cell">…</td>';
            }
            memDisplay += '</tr>';

            // Ligne 2: Valeurs (Contenu de la cellule)
            memDisplay += '<tr>';
            if (start > 0) {
                memDisplay += '<td class="ellipsis-cell">…</td>';
            }
            for (let i = start; i < end; i++) {
                const cellClass = i === state.ptr ? 'active-cell' : '';
                const cellContent = formatMemoryCell(state.memoryFull[i]);
                memDisplay += `<td class="${cellClass}">${cellContent}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td class="ellipsis-cell">…</td>';
            }
            memDisplay += '</tr>';
            memDisplay += '</table>';

            memoryView.innerHTML = `
                <div class="memory-scroll-wrapper">
                    <div class="memory-scroll" role="region" aria-label="Fenêtre mémoire défilable">${memDisplay}</div>
                    <input type="range" class="memory-scroll-slider" min="0" value="0" step="1" aria-label="Défilement horizontal de la mémoire">
                </div>
            `;

            const memoryWrapper = memoryView.querySelector('.memory-scroll-wrapper');
            setupMemoryScrollbar(memoryWrapper);

            // Centrer automatiquement la vue mémoire sur la cellule active
            const activeCellElement = memoryWrapper.querySelector('.active-cell');
            const scrollContainer = memoryWrapper.querySelector('.memory-scroll');
            if (activeCellElement && scrollContainer) {
                const containerWidth = scrollContainer.offsetWidth;
                const cellLeft = activeCellElement.offsetLeft;
                const cellWidth = activeCellElement.offsetWidth;
                // Calcule la position de défilement pour centrer la cellule
                const scrollTarget = cellLeft - (containerWidth / 2) + (cellWidth / 2);
                scrollContainer.scrollLeft = scrollTarget;
            }

            // 4. Mise à jour des informations de threading
            updateThreadInfo(state);
            
            // Nettoyer les threads terminés périodiquement
            if (state.totalThreads > 1 && interpreter) {
                const cleaned = interpreter.cleanupHaltedThreads();
                if (cleaned > 0) {
                    console.log(`🧹 Nettoyage: ${cleaned} threads terminés supprimés`);
                }
            }
            
            // 5. Afficher la vue multi-thread si nécessaire et gérer les zones I/O
            if (state.totalThreads > 1) {
                updateMultiThreadView();
                document.getElementById('multi-thread-view').style.display = 'block';
                
                // Masquer l'état single-thread en mode multi-thread (éviter la redondance)
                document.getElementById('single-thread-state').style.display = 'none';
                
                // Basculer vers les zones d'entrée par thread
                document.getElementById('single-thread-input').style.display = 'none';
                updateMultiThreadInputs();
                document.getElementById('multi-thread-inputs').style.display = 'block';
                
                // Afficher le bouton Step Single en mode multi-thread
                stepSingleBtn.style.display = 'inline-block';
                stepBtn.textContent = '👣 Step (Tous Threads)';
            } else {
                document.getElementById('multi-thread-view').style.display = 'none';
                
                // Afficher l'état single-thread en mode single-thread
                document.getElementById('single-thread-state').style.display = 'block';
                
                // Revenir à la zone d'entrée globale
                document.getElementById('single-thread-input').style.display = 'block';
                document.getElementById('multi-thread-inputs').style.display = 'none';
                
                // Masquer le bouton Step Single en mode single-thread
                stepSingleBtn.style.display = 'none';
                stepBtn.textContent = '👣 Exécuter Pas à Pas';
            }

            // 5.5. Générer les logs d'exécution
            generateThreadExecutionLog();

            // 6. Gestion de la fin du programme
            if (state.halted) {
                runAllBtn.disabled = true;
                stepBtn.disabled = true;
                if (!outputView.innerHTML.includes("terminé")) {
                    outputView.innerHTML += "\n\n--- Programme terminé ---";
                }
            }
        }

        // Nouvelle fonction pour les informations de thread
        function updateThreadInfo(state) {
            const threadInfo = document.getElementById('thread-info');
            let infoHTML = `<strong>🔗 Thread T${state.threadId}</strong>`;
            
            if (state.parentId !== null) {
                infoHTML += ` (Enfant de T${state.parentId})`;
            } else {
                infoHTML += ` (Principal)`;
            }
            
            // Calculer les threads réels
            const manager = interpreter ? interpreter.threadManager : null;
            let activeCount = 0;
            let totalCount = 0;
            if (manager) {
                for (const [threadId, thread] of manager.threads) {
                    totalCount++;
                    if (!thread.halted) {
                        activeCount++;
                    }
                }
            } else {
                activeCount = totalCount = 1;
            }
            
            infoHTML += `<br><strong>Threads:</strong> ${activeCount} actifs`;
            if (totalCount > activeCount) {
                infoHTML += ` (${totalCount - activeCount} terminés)`;
            }
            
            if (state.children.length > 0) {
                infoHTML += `<br><strong>Enfants Créés:</strong> [${state.children.map(id => `T${id}`).join(', ')}]`;
            }
            
            if (state.isForked) {
                infoHTML += `<br><span style="color: #ff6b35;">🔀 Ce thread a été créé par fork</span>`;
            }
            
            threadInfo.innerHTML = infoHTML;
        }

        // Nouvelle fonction pour la vue multi-thread
        function updateMultiThreadView() {
            if (!interpreter) return;
            
            const allStates = interpreter.getAllThreadStates();
            console.log('🔍 Debug updateMultiThreadView - Nombre de threads:', allStates.length);
            console.log('🔍 Debug updateMultiThreadView - États des threads:', allStates);
            const container = document.getElementById('threads-container');
            
            container.innerHTML = '';
            
            allStates.forEach((state, index) => {
                console.log(`🔍 Debug - Affichage thread T${state.threadId}, halted: ${state.halted}`);
                const threadDiv = document.createElement('div');
                const currentThreadId = interpreter ? interpreter.getState().threadId : 0;
                const isCurrentThread = state.threadId === currentThreadId;
                
                let className = 'thread-state ';
                if (isCurrentThread) {
                    className += 'current ';
                } else if (state.halted) {
                    className += 'halted ';
                } else {
                    className += 'active ';
                }
                threadDiv.className = className.trim();
                threadDiv.style.position = 'relative';
                
                // Calculer le progrès du thread (pourcentage d'instructions exécutées)
                const progress = state.code.length > 0 ? (state.ip / state.code.length) * 100 : 0;
                
                // En-tête du thread avec indicateur d'exécution
                const headerHTML = `
                    <div class="thread-header">
                        <span>🔗 Thread T${state.threadId} ${state.parentId !== null ? `(Parent: T${state.parentId})` : '(Principal)'} ${isCurrentThread ? '👑 Actuel' : ''}</span>
                        <span>${state.halted ? '🛑 Arrêté' : '▶️ Actif'}</span>
                    </div>
                    <div class="thread-progress-bar">
                        <div class="thread-progress-fill" style="width: ${Math.min(progress, 100)}%"></div>
                    </div>
                `;
                
                // Zones d'entrée et de sortie par thread
                const ioHTML = generateThreadIOView(state);
                
                // Informations de base avec chronologie
                const steps = executionHistory.get(state.threadId) || 0;
                const detailsHTML = `
                    <div class="thread-details">
                        <strong>PTR:</strong> ${state.ptr} | 
                        <strong>IP:</strong> ${state.ip}/${state.code.length} | 
                        <strong>Cellule:</strong> ${state.memoryFull[state.ptr] || 0} | 
                        <strong>Étapes:</strong> ${steps}<br>
                        <strong>Instruction:</strong> "${state.currentInstruction || 'FIN'}" | 
                        <strong>Forks créés:</strong> ${state.forkCount || 0}<br>
                        ${state.children.length > 0 ? `<strong>Enfants:</strong> [${state.children.map(id => `T${id}`).join(', ')}]` : ''}
                        <div class="thread-timeline">
                            📊 Progrès: ${progress.toFixed(1)}% | 
                            ⏱️ Dernière activité: Étape ${globalStepCounter}
                        </div>
                    </div>
                `;
                
                // Contenu selon le mode d'affichage
                let contentHTML = headerHTML + ioHTML + detailsHTML;
                
                if (showDetailedThreadView) {
                    // Visualisation de la mémoire (fenêtre autour du PTR)
                    const memoryHTML = generateThreadMemoryView(state);
                    
                    // Code en cours d'exécution avec mise en évidence
                    const codeHTML = generateThreadCodeView(state);
                    
                    // Log d'exécution récent
                    const logHTML = generateThreadExecutionLog(state.threadId);
                    
                    contentHTML += memoryHTML + codeHTML + logHTML;
                }
                
                threadDiv.innerHTML = contentHTML;
                container.appendChild(threadDiv);
                
                // Configurer les gestionnaires d'événements pour les zones I/O
                setupThreadIOHandlers(threadDiv, state.threadId);
                
                // Ajouter effet visuel lors de l'exécution
                if (!state.halted && Math.random() < 0.3) { // Animation occasionnelle
                    setTimeout(() => {
                        const indicator = document.createElement('div');
                        indicator.className = 'thread-execution-indicator executing';
                        threadDiv.appendChild(indicator);
                        setTimeout(() => indicator.remove(), 500);
                    }, index * 100);
                }
            });
        }

        // Génère la vue I/O pour un thread (entrée seulement, sortie globale)
        function generateThreadIOView(state) {
            const inputValue = threadInputData.get(state.threadId) || '';
            
            if (showDetailedThreadView) {
                // Vue détaillée avec zone d'entrée complète
                return `
                    <div class="thread-io">
                        <div class="thread-io-section">
                            <label class="thread-io-label">📥 Données d'Entrée (Input):</label>
                            <textarea class="thread-input" 
                                      data-thread-id="${state.threadId}" 
                                      placeholder="Données pour les commandes ',' du thread T${state.threadId}">${inputValue}</textarea>
                        </div>
                    </div>
                `;
            } else {
                // Vue compacte avec zone d'entrée réduite
                return `
                    <div class="thread-io">
                        <div class="thread-io-section">
                            <label class="thread-io-label">📥 Input T${state.threadId}:</label>
                            <textarea class="thread-input" 
                                      data-thread-id="${state.threadId}" 
                                      placeholder="Input T${state.threadId}">${inputValue}</textarea>
                        </div>
                    </div>
                `;
            }
        }



        // Callback appelé à chaque output de thread
        window.onThreadOutput = function(threadId, currentOutput) {
            console.log(`🎯 Thread T${threadId} output update: length=${currentOutput.length}, chars=[${currentOutput.split('').map(c => c.charCodeAt(0)).join(',')}]`);
            threadOutputsCache.set(threadId, currentOutput);
        };

        // Callback appelé à la fin de runAllThreads pour capturer les outputs finaux
        window.captureThreadOutputsForRunAll = function(results) {
            console.log('🎯 captureThreadOutputsForRunAll called with results:', results);
            results.forEach(result => {
                if (result.output && result.output.length > 0) {
                    console.log(`🎯 Capturing final output for T${result.threadId}: length=${result.output.length}`);
                    threadOutputsCache.set(result.threadId, result.output);
                }
            });
            console.log('🎯 Final cache after runAll:', Array.from(threadOutputsCache.entries()));
        };

        // Capture les sorties des threads pendant l'exécution
        function captureThreadOutputs() {
            console.log('📦 DEBUG captureThreadOutputs: Starting capture...');
            
            if (!interpreter) {
                console.log('📦 DEBUG: No interpreter found');
                return;
            }
            
            // Essayer d'abord la méthode normale
            let allStates = interpreter.getAllThreadStates();
            console.log('📦 DEBUG: interpreter.getAllThreadStates() =', allStates);
            
            // Fallback vers le gestionnaire global
            if (allStates.length === 0 && BrainfuckInterpreter.threadManager) {
                console.log('📦 DEBUG: Trying global thread manager');
                allStates = [];
                for (const [threadId, thread] of BrainfuckInterpreter.threadManager.threads) {
                    const state = thread.getState();
                    console.log(`📦 DEBUG: Thread T${threadId} state:`, state);
                    allStates.push(state);
                }
                console.log('📦 DEBUG: Global states found:', allStates);
            }
            
            // Si toujours aucun état, vérification directe des threads
            if (allStates.length === 0) {
                console.log('📦 DEBUG: No states found, checking threads directly...');
                if (BrainfuckInterpreter.threadManager && BrainfuckInterpreter.threadManager.threads) {
                    console.log('📦 DEBUG: Direct thread inspection:');
                    for (const [tid, thread] of BrainfuckInterpreter.threadManager.threads) {
                        console.log(`   T${tid}: halted=${thread.halted}, output="${thread.output}", length=${(thread.output||'').length}`);
                        if (thread.output && thread.output.length > 0) {
                            threadOutputsCache.set(tid, thread.output);
                        }
                    }
                }
            }
            
            // Mettre à jour le cache avec les sorties actuelles
            let updatedCount = 0;
            allStates.forEach(state => {
                const output = state.output || '';
                console.log(`📦 DEBUG: Thread T${state.threadId} output: "${output}" (length: ${output.length})`);
                if (output.length > 0) {
                    threadOutputsCache.set(state.threadId, output);
                    updatedCount++;
                }
            });
            
            console.log(`📦 Cache des sorties mis à jour: ${updatedCount} threads with output`);
            console.log('📦 Current cache:', Array.from(threadOutputsCache.entries()));
        }

        // Met à jour la sortie globale unifiée avec annotations des threads
        function updateGlobalOutput() {
            if (!interpreter) {
                outputView.textContent = "En attente d'exécution...";
                document.getElementById('output-legend').style.display = 'none';
                return;
            }
            
            // Capturer les sorties des threads actifs seulement si le cache est vide
            // (pour éviter d'écraser le cache rempli par runAllThreads)
            if (threadOutputsCache.size === 0) {
                console.log('🎨 DEBUG: Cache vide, capturing thread outputs...');
                captureThreadOutputs();
            } else {
                console.log('🎨 DEBUG: Cache non-vide, skipping capture to preserve data');
            }
            
            const allStates = interpreter.getAllThreadStates();
            const isMultiThread = allStates.length > 1 || threadOutputsCache.size > 1;
            
            console.log('🎨 DEBUG updateGlobalOutput: allStates =', allStates);
            console.log('🎨 DEBUG updateGlobalOutput: threadOutputsCache =', threadOutputsCache);
            console.log('🎨 DEBUG updateGlobalOutput: isMultiThread =', isMultiThread);
            
            // Utiliser le cache si nous avons des outputs capturés, même en single-thread
            if (threadOutputsCache.size > 0) {
                console.log('🎨 DEBUG: Taking cache path with', threadOutputsCache.size, 'threads');
                // Mode avec cache : utiliser les sorties capturées
                const globalOutput = buildAnnotatedOutput(threadOutputsCache);
                
                console.log('🎨 DEBUG updateGlobalOutput: setting innerHTML to:', globalOutput);
                
                // Afficher avec le HTML coloré
                outputView.innerHTML = globalOutput;
                console.log('🎨 DEBUG: After setting innerHTML, outputView.innerHTML =', outputView.innerHTML);
                
                // Diagnostic complet
                const outputElement = document.getElementById('output-view');
                console.log('🔍 DIAGNOSTIC outputView element:', outputElement);
                console.log('🔍 DIAGNOSTIC tagName:', outputElement.tagName);
                console.log('🔍 DIAGNOSTIC computed styles:', window.getComputedStyle(outputElement));
                console.log('🔍 DIAGNOSTIC color property:', window.getComputedStyle(outputElement).color);
                console.log('🔍 DIAGNOSTIC background property:', window.getComputedStyle(outputElement).backgroundColor);
                
                // Chercher le span avec la classe thread-output-T0
                setTimeout(() => {
                    const threadSpan = outputElement.querySelector('.thread-output-T0');
                    if (threadSpan) {
                        console.log('🔍 DIAGNOSTIC thread span found:', threadSpan);
                        console.log('🔍 DIAGNOSTIC thread span styles:', window.getComputedStyle(threadSpan));
                        console.log('🔍 DIAGNOSTIC thread span color:', window.getComputedStyle(threadSpan).color);
                        console.log('🔍 DIAGNOSTIC thread span background:', window.getComputedStyle(threadSpan).backgroundColor);
                    } else {
                        console.log('🔍 DIAGNOSTIC: No thread span found!');
                    }
                }, 100);
                
                // Afficher la légende des threads s'il y a des outputs dans le cache
                if (threadOutputsCache.size > 0) {
                    // Créer des états simulés pour la légende basés sur le cache
                    const simulatedStates = [];
                    for (const [threadId, output] of threadOutputsCache) {
                        simulatedStates.push({
                            threadId: threadId,
                            parentId: threadId === 0 ? null : 0, // Supposer que T0 est le parent
                            output: output
                        });
                    }
                    updateThreadLegend(simulatedStates);
                    
                    if (threadOutputsCache.size > 1) {
                        document.getElementById('output-legend').style.display = 'block';
                    } else {
                        document.getElementById('output-legend').style.display = 'none';
                    }
                } else {
                    document.getElementById('output-legend').style.display = 'none';
                }
                
            } else {
                console.log('🎨 DEBUG: Taking single-thread path (cache is empty)');
                // Mode single-thread : sortie simple avec formatage des caractères
                const state = interpreter.getState();
                const output = state.output || '';
                
                if (output.length > 0) {
                    // Formatter chaque caractère pour afficher les non-imprimables en hexa
                    let formattedOutput = '';
                    for (let i = 0; i < output.length; i++) {
                        const charCode = output.charCodeAt(i);
                        formattedOutput += formatOutputChar(charCode);
                    }
                    outputView.innerHTML = formattedOutput;
                } else {
                    outputView.innerHTML = '<span style="color: #999; font-style: italic;">Aucune sortie produite</span>';
                }
                
                document.getElementById('output-legend').style.display = 'none';
            }
        }

        // Formate un caractère pour l'affichage (imprimable ou hexa) avec couleur de thread
        function formatOutputChar(charCode, threadId = null) {
            // Les caractères imprimables ASCII sont généralement entre 32 (espace) et 126 (~)
            if (charCode >= 32 && charCode <= 126) {
                // Pour les caractères imprimables, on laisse le wrapper du thread gérer la couleur
                return escapeHtml(String.fromCharCode(charCode));
            } else {
                // Pour les caractères non imprimables, afficher en hexadécimal
                const hexValue = '0x' + charCode.toString(16).toUpperCase().padStart(2, '0');
                
                // Noms spéciaux pour certains caractères courants
                let charName = '';
                switch (charCode) {
                    case 0: charName = 'NULL'; break;
                    case 7: charName = 'BELL'; break;
                    case 8: charName = 'BACKSPACE'; break;
                    case 9: charName = 'TAB'; break;
                    case 10: charName = 'LF (Nouvelle ligne)'; break;
                    case 13: charName = 'CR (Retour chariot)'; break;
                    case 27: charName = 'ESC'; break;
                    default: charName = `Code ASCII ${charCode}`;
                }
                
                // Utiliser les classes CSS au lieu des styles inline
                return `<span class="hex-char" title="${charName}">${hexValue}</span>`;
            }
        }

        // Construit une sortie annotée avec couleurs pour identifier les threads
        function buildAnnotatedOutput(threadOutputs) {
            let result = '';
            let hasContent = false;
            
            console.log('🎨 DEBUG buildAnnotatedOutput: threadOutputs =', threadOutputs);
            
            // Trier les threads par ID pour un affichage cohérent
            const sortedThreads = Array.from(threadOutputs.entries()).sort((a, b) => a[0] - b[0]);
            
            sortedThreads.forEach(([threadId, output]) => {
                if (output && output.length > 0) {
                    console.log(`🎨 DEBUG: Processing thread T${threadId}, output length: ${output.length}`);
                    
                    if (hasContent) {
                        // Ajouter un petit séparateur visuel entre les outputs des threads
                        result += '<span style="color: #ccc; margin: 0 2px;">|</span>';
                    }
                    
                    // Formatter chaque caractère de la sortie avec la couleur du thread
                    let formattedOutput = '';
                    for (let i = 0; i < output.length; i++) {
                        const charCode = output.charCodeAt(i);
                        const formatted = formatOutputChar(charCode, threadId);
                        formattedOutput += formatted;
                    }
                    
                    // Utiliser les classes CSS avec identification du thread
                    const threadSpan = `<span class="thread-output-T${threadId}" title="Thread T${threadId}">${formattedOutput}</span>`;
                    console.log(`🎨 DEBUG: Thread T${threadId} span:`, threadSpan);
                    
                    result += threadSpan;
                    hasContent = true;
                }
            });
            
            // Si aucun thread n'a produit de sortie, afficher un message neutre
            if (!hasContent) {
                return '<span style="color: #999; font-style: italic;">Aucune sortie produite</span>';
            }
            
            console.log('🎨 DEBUG: Final result HTML:', result);
            return result;
        }

        // Met à jour la légende des couleurs de threads
        function updateThreadLegend(allStates) {
            const legendContainer = document.getElementById('thread-colors-legend');
            if (!legendContainer) return;
            
            let legendHTML = '';
            const threadColors = [
                '#2196F3', '#4CAF50', '#FF9800', '#9C27B0', 
                '#F44336', '#795548', '#607D8B', '#E91E63'
            ];
            
            allStates.forEach((state, index) => {
                const color = threadColors[state.threadId % threadColors.length];
                const hasNonPrintable = state.output && /[\x00-\x1F\x7F-\xFF]/.test(state.output);
                const badgeExample = hasNonPrintable ? `<span class="hex-char" style="border-color: ${color}; background: ${color}20; color: ${color}; font-size: 0.8em;">0x0A</span>` : '';
                
                legendHTML += `
                    <span class="thread-legend-item">
                        <span class="thread-legend-color" style="background-color: ${color};"></span>
                        T${state.threadId}${state.parentId !== null ? ` (parent: T${state.parentId})` : ' (principal)'}
                        ${badgeExample}
                    </span>
                `;
            });
            
            legendContainer.innerHTML = legendHTML;
        }

        // Met à jour les zones d'entrée en mode multi-thread
        function updateMultiThreadInputs() {
            if (!interpreter) return;
            
            const allStates = interpreter.getAllThreadStates();
            const container = document.getElementById('multi-thread-inputs');
            if (!container) return;
            
            container.innerHTML = '';
            
            allStates.forEach(state => {
                const inputValue = threadInputData.get(state.threadId) || '';
                const inputDiv = document.createElement('div');
                inputDiv.className = 'multi-thread-input';
                
                inputDiv.innerHTML = `
                    <label class="multi-thread-input-label">
                        📥 Thread T${state.threadId} - Données d'Entrée:
                    </label>
                    <textarea data-thread-id="${state.threadId}" 
                              placeholder="Données pour les commandes ',' du thread T${state.threadId}">${inputValue}</textarea>
                `;
                
                container.appendChild(inputDiv);
                
                // Configurer les gestionnaires d'événements
                const textarea = inputDiv.querySelector('textarea');
                if (textarea) {
                    textarea.addEventListener('input', (e) => {
                        const newValue = e.target.value;
                        threadInputData.set(state.threadId, newValue);
                        console.log(`📝 Input thread T${state.threadId} mis à jour: "${newValue}"`);
                        
                        // Mettre à jour l'input du thread correspondant dans l'interpréteur
                        if (interpreter && interpreter.threadManager) {
                            const thread = interpreter.threadManager.threads.get(state.threadId);
                            if (thread) {
                                // Comparer avec la version chaîne du tableau actuel
                                const currentInputString = Array.isArray(thread.input) ? thread.input.join('') : (thread.input || '');
                                if (currentInputString !== newValue) {
                                    thread.input = newValue.split(''); // Convertir en tableau
                                    // Pas de inputPointer car BrainfuckInterpreter utilise shift()
                                    console.log(`🔄 Thread T${state.threadId} input synchronisé: "${newValue}"`);
                                }
                            }
                        }
                    });
                }
            });
        }

        // Configure les gestionnaires d'événements pour les zones I/O d'un thread
        function setupThreadIOHandlers(threadDiv, threadId) {
            const inputArea = threadDiv.querySelector(`textarea[data-thread-id="${threadId}"]`);
            if (inputArea) {
                inputArea.addEventListener('input', (e) => {
                    const newValue = e.target.value;
                    threadInputData.set(threadId, newValue);
                    console.log(`📝 Input thread T${threadId} mis à jour: "${newValue}"`);
                    
                    // Mettre à jour l'input du thread correspondant dans l'interpréteur
                    if (interpreter && interpreter.threadManager) {
                        const thread = interpreter.threadManager.threads.get(threadId);
                        if (thread) {
                            // Comparer avec la version chaîne du tableau actuel
                            const currentInputString = Array.isArray(thread.input) ? thread.input.join('') : (thread.input || '');
                            if (currentInputString !== newValue) {
                                thread.input = newValue.split(''); // Convertir en tableau
                                // Pas de inputPointer car BrainfuckInterpreter utilise shift()
                                console.log(`🔄 Thread T${threadId} input synchronisé: "${newValue}"`);
                            }
                        }
                    }
                });
            }
        }

        // Génère un log d'exécution pour un thread
        function generateThreadExecutionLog(threadId) {
            const history = executionHistory.get(threadId) || 0;
            const logs = [
                `Étape ${Math.max(0, globalStepCounter - 2)}: Instruction exécutée`,
                `Étape ${Math.max(0, globalStepCounter - 1)}: État mis à jour`,
                `Étape ${globalStepCounter}: État actuel`
            ];
            
            return `
                <div class="execution-log">
                    <strong>📝 Log d'exécution:</strong><br>
                    ${logs.slice(-3).map(log => `• ${log}`).join('<br>')}
                </div>
            `;
        }

        // Génère la vue mémoire pour un thread
        function generateThreadMemoryView(state) {
            const windowRadius = 5; // Fenêtre plus petite pour économiser l'espace
            const memoryLength = state.memoryFull.length;
            const start = Math.max(0, state.ptr - windowRadius);
            const end = Math.min(state.ptr + windowRadius + 1, memoryLength);

            let memDisplay = '<div class="thread-memory"><strong>Mémoire:</strong><div class="thread-memory-scroll"><table>';
            
            // Ligne 1: Index (PTR)
            memDisplay += '<tr class="header-row">';
            if (start > 0) {
                memDisplay += '<td>…</td>';
            }
            for (let i = start; i < end; i++) {
                memDisplay += `<td>${i}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td>…</td>';
            }
            memDisplay += '</tr>';

            // Ligne 2: Valeurs
            memDisplay += '<tr>';
            if (start > 0) {
                memDisplay += '<td>…</td>';
            }
            for (let i = start; i < end; i++) {
                const cellClass = i === state.ptr ? 'active-cell' : '';
                const value = state.memoryFull[i];
                const hexValue = '0x' + value.toString(16).toUpperCase().padStart(2, '0');
                let cellContent = hexValue;
                
                // Ajouter le caractère ASCII si imprimable
                if (value >= 32 && value <= 126) {
                    const char = escapeHtml(String.fromCharCode(value));
                    cellContent += `<br>'${char}'`;
                }
                
                memDisplay += `<td class="${cellClass}">${cellContent}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td>…</td>';
            }
            memDisplay += '</tr>';
            memDisplay += '</table></div></div>';
            
            return memDisplay;
        }

        // Génère la vue code pour un thread
        function generateThreadCodeView(state) {
            if (!state.code || state.code.length === 0) {
                return '<div class="thread-code"><em>Aucun code</em></div>';
            }
            
            // Afficher une fenêtre autour de l'IP actuel
            const windowRadius = 10;
            const start = Math.max(0, state.ip - windowRadius);
            const end = Math.min(state.ip + windowRadius + 1, state.code.length);
            
            let codeDisplay = '<div class="thread-code"><strong>Code (IP=' + state.ip + '):</strong><br>';
            
            if (start > 0) {
                codeDisplay += '…';
            }
            
            for (let i = start; i < end; i++) {
                const char = state.code[i];
                if (i === state.ip) {
                    // Instruction actuelle en surbrillance
                    codeDisplay += `<span style="background: #ff9900; color: white; padding: 1px 2px; border-radius: 2px;">${escapeHtml(char)}</span>`;
                } else {
                    // Coloration normale
                    const tokenClass = BF_TOKEN_CLASSES[char] || 'bf-comment';
                    codeDisplay += `<span class="${tokenClass}">${escapeHtml(char)}</span>`;
                }
            }
            
            if (end < state.code.length) {
                codeDisplay += '…';
            }
            
            codeDisplay += '</div>';
            return codeDisplay;
        }

        // --- Gestionnaires d'événements ---

        runAllBtn.addEventListener('click', () => {
            // Réinitialiser s'il n'y a pas d'interpréteur ou si l'exécution précédente est terminée
            if (!interpreter || interpreter.getState().halted) initializeInterpreter();
            if (interpreter) {
                try {
                    const state = interpreter.getState();
                    console.log('🔍 Debug - state.totalThreads:', state.totalThreads);
                    console.log('🔍 Debug - getAllThreadStates().length:', interpreter.getAllThreadStates().length);
                    
                    // Toujours démarrer en mode multi-thread pour détecter les forks dynamiquement
                    console.log('🚀 Démarrage exécution multi-thread (détection dynamique des forks)...');
                    const results = interpreter.runAllThreads();
                    console.log('✅ Exécution terminée. Résultats:', results);
                    
                    // Log des résultats sans popup
                    if (results.length > 1) {
                        console.log(`✅ Exécution multi-thread terminée avec ${results.length} threads`);
                        results.forEach(r => {
                            console.log(`Thread T${r.threadId}: "${r.output}"`);
                        });
                    } else {
                        console.log('✅ Exécution terminée (pas de forks détectés)');
                    }
                    
                    console.log('🔍 AVANT updateUI() - outputView.innerHTML =', document.getElementById('output-view').innerHTML);
                    updateUI();
                    console.log('🔍 APRES updateUI() - outputView.innerHTML =', document.getElementById('output-view').innerHTML);
                } catch (error) {
                    alert(`❌ Erreur d'exécution: ${error.message}`);
                    console.error(error);
                }
            }
        });

        stepBtn.addEventListener('click', () => {
            if (!interpreter || interpreter.getState().halted) initializeInterpreter(); 
            if (interpreter) {
                try {
                    const state = interpreter.getState();
                    
                    // Vérifier le nombre réel de threads dans le gestionnaire
                    const allThreadStates = interpreter.getAllThreadStates();
                    const hasMultipleThreads = allThreadStates.length > 1;
                    
                    console.log(`🔍 Debug step: ${allThreadStates.length} threads, hasMultiple: ${hasMultipleThreads}`);
                    allThreadStates.forEach(t => {
                        console.log(`  T${t.threadId}: IP=${t.ip}/${t.code.length}, halted=${t.halted}, instruction='${t.currentInstruction || 'EOF'}'`);
                    });
                    
                    // Incrémenter le compteur global
                    globalStepCounter++;
                    const stepNumberEl = document.getElementById('step-number');
                    if (stepNumberEl) stepNumberEl.textContent = globalStepCounter;
                    
                    const stepCounterEl = document.getElementById('step-counter');
                    if (stepCounterEl) stepCounterEl.style.display = 'block';
                    
                    if (hasMultipleThreads) {
                        // Mode multi-thread: exécuter une étape pour chaque thread actif
                        const manager = interpreter.threadManager;
                        if (!manager) {
                            console.error('❌ Pas de gestionnaire de threads disponible');
                            return;
                        }
                        
                        let anyProgress = false;
                        
                        // Créer un snapshot des threads AVANT l'itération pour éviter les modifications concurrentes
                        const threadsSnapshot = Array.from(manager.threads.entries());
                        console.log(`🔄 Executing step for ${threadsSnapshot.length} threads`);
                        
                        for (const [threadId, thread] of threadsSnapshot) {
                            // Vérifier que le thread existe toujours dans le gestionnaire
                            if (!manager.threads.has(threadId)) {
                                console.log(`⚠️ Thread T${threadId} déjà supprimé, ignoré`);
                                continue;
                            }
                            
                            if (!thread.halted) {
                                // Vérifier si le thread a atteint la fin AVANT d'appeler step()
                                if (thread.ip >= thread.code.length) {
                                    console.log(`🛑 Thread T${threadId} marqué comme terminé (IP: ${thread.ip}/${thread.code.length})`);
                                    thread.halted = true;
                                    continue;
                                }
                                
                                // Incrémenter l'historique du thread
                                executionHistory.set(threadId, (executionHistory.get(threadId) || 0) + 1);
                                
                                const continued = thread.step();
                                if (continued) {
                                    anyProgress = true;
                                    
                                    // Effet visuel d'exécution
                                    console.log(`⚡ T${threadId}: ${thread.code[thread.ip - 1] || 'N/A'} (IP: ${thread.ip - 1} → ${thread.ip})`);
                                } else {
                                    // Thread terminé - pas besoin de manipulation manuelle
                                    console.log(`🛑 Thread T${threadId} terminé`);
                                }
                                
                                // Capturer les outputs après chaque step
                                captureThreadOutputs();
                            }
                        }
                        
                        // Laisser le nettoyage automatique se faire
                        // (suppression du nettoyage manuel conflictuel)
                        
                        // Vérifier si tous les threads sont terminés
                        let activeCount = 0;
                        for (const [threadId, thread] of manager.threads) {
                            if (!thread.halted) activeCount++;
                        }
                        
                        if (activeCount === 0) {
                            console.log('🎯 Tous les threads sont terminés');
                            const stepCounterEl = document.getElementById('step-counter');
                            if (stepCounterEl) stepCounterEl.style.display = 'none';
                        }
                    } else {
                        // Mode single-thread classique
                        const threadId = interpreter.threadId;
                        executionHistory.set(threadId, (executionHistory.get(threadId) || 0) + 1);
                        
                        interpreter.step();
                        console.log(`⚡ T${threadId}: ${interpreter.code[interpreter.ip - 1] || 'N/A'} (IP: ${interpreter.ip - 1} → ${interpreter.ip})`);
                    }
                    
                    // Forcer le nettoyage des threads terminés après chaque step
                    console.log('🧹 Nettoyage forcé après step...');
                    if (interpreter) {
                        interpreter.cleanupHaltedThreads();
                    }
                    
                    // Capturer les sorties après chaque étape
                    captureThreadOutputs();
                    
                    updateUI();
                } catch (error) {
                    alert(`❌ Erreur d'exécution step: ${error.message}`);
                    console.error(error);
                }
            }
        });

        stepSingleBtn.addEventListener('click', () => {
            if (!interpreter) return;
            
            try {
                // Exécuter une étape seulement pour le thread principal (ou actuel)
                const continued = interpreter.step();
                if (!continued) {
                    console.log(`🛑 Thread T${interpreter.threadId} terminé`);
                }
                updateUI();
            } catch (error) {
                alert(`❌ Erreur d'exécution step single: ${error.message}`);
                console.error(error);
            }
        });

        resetBtn.addEventListener('click', () => {
            // Réinitialisation complète - le gestionnaire de threads sera recréé avec la nouvelle instance
            
            // Reset des compteurs et données
            globalStepCounter = 0;
            executionHistory.clear();
            threadInputData.clear();
            
            // Reset sécurisé des éléments DOM
            const stepNumberEl = document.getElementById('step-number');
            if (stepNumberEl) stepNumberEl.textContent = '0';
            
            const stepCounterEl = document.getElementById('step-counter');
            if (stepCounterEl) stepCounterEl.style.display = 'none';
            
            // Nettoyer l'interface
            const outputEl = document.querySelector('#output pre');
            if (outputEl) outputEl.textContent = '';
            
            const memoryViewEl = document.getElementById('memory-view');
            if (memoryViewEl) memoryViewEl.innerHTML = '';
            
            const executionLogEl = document.getElementById('execution-log');
            if (executionLogEl) executionLogEl.innerHTML = '';
            
            // Remettre les zones I/O en mode single-thread
            document.getElementById('single-thread-input').style.display = 'block';
            document.getElementById('multi-thread-inputs').style.display = 'none';
            document.getElementById('multi-thread-view').style.display = 'none';
            document.getElementById('output-legend').style.display = 'none';
            
            // Réafficher l'état single-thread
            document.getElementById('single-thread-state').style.display = 'block';
            
            console.clear();
            console.log('🔄 Interpréteur réinitialisé');
            
            initializeInterpreter();
        });

        // Gestionnaire pour la limite de threads
        document.getElementById('max-threads').addEventListener('change', (e) => {
            const newLimit = parseInt(e.target.value);
            if (newLimit > 0 && interpreter) {
                interpreter.setMaxThreads(newLimit);
                console.log(`Limite de threads mise à jour: ${newLimit}`);
            }
        });

        // Variable pour contrôler la vue détaillée des threads
        let showDetailedThreadView = true;
        let globalStepCounter = 0;
        let executionHistory = new Map(); // Historique d'exécution par thread
        let threadInputData = new Map(); // Données d'entrée par thread
        
        // Informations de version de l'application
        const APP_VERSION = '1.3.0';
        const BUILD_DATE = '2025-10-01';
        
        // Gestionnaire pour le bouton de bascule de vue
        document.getElementById('toggle-thread-details').addEventListener('click', () => {
            showDetailedThreadView = !showDetailedThreadView;
            const button = document.getElementById('toggle-thread-details');
            button.textContent = showDetailedThreadView ? '👁️ Vue Compacte' : '👁️ Vue Détaillée';
            
            // Mettre à jour l'affichage immédiatement
            if (interpreter && interpreter.getState().totalThreads > 1) {
                updateMultiThreadView();
            }
        });

        // Initialisation après le chargement complet
        window.addEventListener('load', () => {
            if (typeof BrainfuckInterpreter === 'undefined') {
                alert("Erreur: Le fichier 'BrainfuckInterpreter.js' n'a pas été trouvé ou chargé correctement. Vérifiez le chemin.");
            } else {
                // Initialiser le bouton de vue
                const toggleButton = document.getElementById('toggle-thread-details');
                toggleButton.textContent = showDetailedThreadView ? '👁️ Vue Compacte' : '👁️ Vue Détaillée';
                
                initializeInterpreter();
            }
        });

    </script>
    
    <!-- Pied de page avec numéro de version -->
    <footer style="margin-top: 50px; padding: 20px 0; border-top: 1px solid #eee; text-align: center; color: #999; font-size: 12px;">
        <div id="version-info">
            🧠 BrainJS - Interpréteur Brainfuck Multithreading
            <br>
            <span style="font-family: monospace;">Version <span id="app-version">1.3.0</span> • Build <span id="build-date">2025-10-01</span></span>
            <br>
            <a href="https://github.com/vfarcy/brainfuck" style="color: #666; text-decoration: none;" target="_blank">
                📦 Code source sur GitHub
            </a>
        </div>
    </footer>
</body>
</html>
