<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🧠 BrainJS: Interpréteur Brainfuck</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }
        h1, h2 {
            color: #333;
        }
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
        }
        .editor-wrapper {
            position: relative;
            width: 100%;
            margin-top: 8px;
            margin-bottom: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
            overflow: hidden;
            display: grid; /* Utiliser grid pour superposer les éléments */
        }
        .editor-wrapper textarea,
        .editor-wrapper pre {
            grid-area: 1 / 1 / 2 / 2; /* Placer les deux dans la même cellule de la grille */
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
            tab-size: 2;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .editor-wrapper pre {
            pointer-events: none;
            background-color: #fff;
        }
        .editor-wrapper textarea { 
            z-index: 1;
            border: none;
            background-color: transparent;
            color: transparent;
            caret-color: #222;
            resize: vertical;
            -webkit-text-fill-color: transparent;
        }
        .editor-wrapper textarea:focus {
            outline: none;
        }
        .code-editor::selection {
            background-color: rgba(33, 150, 243, 0.35);
        }
        .bf-token {
            display: inline;
            color: #444;
        }
        .bf-comment {
            color: #bdbdbd;
        }
        .bf-move-right,
        .bf-move-left {
            color: #1565c0;
        }
        .bf-increment,
        .bf-decrement {
            color: #2e7d32;
        }
        .bf-output {
            color: #ef6c00;
        }
        .bf-input {
            color: #8e24aa;
        }
        .bf-loop-start,
        .bf-loop-end {
            color: #d81b60;
        }
        .bf-fork {
            color: #ff6b35;
            font-weight: bold;
        }
        .bf-active {
            background-color: #ff9900;
            color: #fff !important;
            border-radius: 3px;
            padding: 0 2px;
        }
        button {
            padding: 10px 15px;
            margin-right: 10px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        #run-all { background-color: #4CAF50; color: white; }
        #run-all:hover:not(:disabled) { background-color: #45a049; }
        #step-btn { background-color: #2196F3; color: white; }
        #step-btn:hover:not(:disabled) { background-color: #0b7dda; }
        #reset-btn { background-color: #f44336; color: white; }
        #reset-btn:hover:not(:disabled) { background-color: #da190b; }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        /* --- Styles de Sortie et Mémoire --- */
        #output-view, #code-view {
            white-space: pre-wrap;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #fff;
            min-height: 50px;
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
            overflow: auto;
        }
        #memory-view {
            max-width: 100%;
        }
        .memory-scroll-wrapper {
            width: 100%;
            max-width: 100%;
        }
        .memory-scroll {
            overflow-x: auto;
            overflow-y: hidden;
            padding-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
        }
        .memory-scroll::-webkit-scrollbar {
            height: 8px;
        }
        .memory-scroll::-webkit-scrollbar-thumb {
            background-color: rgba(0,0,0,0.25);
            border-radius: 4px;
        }
        .memory-scroll::-webkit-scrollbar-track {
            background-color: rgba(0,0,0,0.05);
        }
        .memory-scroll table {
            border-collapse: collapse;
            font-size: 14px;
            min-width: 500px;
            width: max-content;
        }
        .memory-scroll td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
            white-space: nowrap;
        }
        .memory-scroll-slider {
            width: 100%;
            margin-top: 6px;
            appearance: none;
            height: 6px;
            border-radius: 4px;
            background: #d0d0d0;
            cursor: pointer;
        }
        .memory-scroll-slider:focus {
            outline: 2px solid rgba(33, 150, 243, 0.4);
            outline-offset: 2px;
        }
        .memory-scroll-slider::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2196F3;
            border: none;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
        }
        .memory-scroll-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #2196F3;
            border: none;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
        }
        .header-row td {
            font-weight: bold;
            background-color: #f0f0f0;
            color: #555;
        }
        .active-cell {
            background-color: #ff9900 !important;
            color: white;
            font-weight: bold;
            border-color: #cc7a00 !important;
        }
        .ellipsis-cell {
            font-weight: bold;
            color: #999;
        }
        
        /* Styles pour le multithreading */
        #thread-info {
            background: linear-gradient(135deg, #e3f2fd, #f0f8ff);
            border: 2px solid #4a90e2;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        #multi-thread-view {
            margin-top: 20px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 12px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        
        .thread-state {
            background: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            transition: all 0.3s ease;
        }
        
        .thread-state:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .thread-state.active {
            border-left: 5px solid #4caf50;
            background: #f8fff8;
        }
        
        .thread-state.halted {
            border-left: 5px solid #f44336;
            background: #fff8f8;
        }
        
        .thread-state.current {
            border: 2px solid #2196F3;
            background: #e3f2fd;
        }
        
        .thread-execution-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4caf50;
            animation: pulse 1s infinite;
        }
        
        .thread-execution-indicator.executing {
            background: #ff9900;
            animation: flash 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        @keyframes flash {
            0% { background: #ff9900; transform: scale(1); }
            50% { background: #ffeb3b; transform: scale(1.2); }
            100% { background: #ff9900; transform: scale(1); }
        }
        
        .thread-timeline {
            margin-top: 10px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .step-counter {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #2196F3;
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .thread-progress-bar {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .thread-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        .execution-log {
            max-height: 100px;
            overflow-y: auto;
            font-size: 10px;
            background: #fafafa;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            padding: 5px;
            margin-top: 5px;
        }
        
        .thread-header {
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .thread-details {
            color: #666;
            line-height: 1.4;
        }
        
        .thread-memory {
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 8px;
        }
        
        .thread-memory-scroll {
            overflow-x: auto;
            max-width: 100%;
            margin-top: 5px;
        }
        
        .thread-memory table {
            border-collapse: collapse;
            font-size: 11px;
            min-width: 300px;
        }
        
        .thread-memory td {
            border: 1px solid #ddd;
            padding: 4px 6px;
            text-align: center;
            white-space: nowrap;
        }
        
        .thread-memory .header-row td {
            font-weight: bold;
            background-color: #f0f0f0;
            color: #555;
            font-size: 10px;
        }
        
        .thread-memory .active-cell {
            background-color: #ff9900 !important;
            color: white;
            font-weight: bold;
            border-color: #cc7a00 !important;
        }
        
        .thread-code {
            margin-top: 8px;
            padding: 6px;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 11px;
            max-height: 60px;
            overflow-y: auto;
        }
        
        #max-threads-control {
            margin: 10px 0;
            padding: 10px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
        }
        
        .warning-text {
            color: #856404;
            font-size: 12px;
            margin-top: 5px;
        }
            /* Logs d'exécution */
        .execution-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #2196F3;
        }

        .thread-logs {
            margin-top: 15px;
        }

        .thread-log-item {
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            background: #fff;
        }

        .thread-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .thread-id {
            font-weight: bold;
            color: #333;
        }

        .thread-steps {
            font-size: 0.9em;
            color: #666;
        }

        .thread-progress-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }

        .thread-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #2196F3);
            transition: width 0.3s ease;
        }

        </style>
</head>
<body>

    <h1>🧠 BrainJS: Interpréteur Brainfuck</h1>

    <label for="bf-code">Entrez votre programme Brainfuck :</label>
    <div class="editor-wrapper">
        <pre id="code-highlight" aria-hidden="true"></pre>
        <textarea id="bf-code" class="code-editor" rows="10" cols="80">++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.

// Exemples avec fork (commande 'f'):
// Simple: ++f    (Parent: cell[0]=0, Enfant: cell[1]=1)
// Test: +++f>+++f>+++
// ⚠️ Danger: +[f+]  (Explosion de threads!)</textarea>
    </div>
    
    <p>
        <button id="run-all" aria-label="Exécuter d'un coup">▶ Exécuter D'un Coup</button>
        <button id="step-btn" aria-label="Exécuter pas à pas">👣 Step (Tous Threads)</button>
        <button id="step-single-btn" aria-label="Exécuter pas à pas thread unique" style="display: none;">👤 Step (Thread Actuel)</button>
        <button id="reset-btn" aria-label="Réinitialiser">🔄 Réinitialiser</button>
    </p>
    
    <!-- Contrôle pour la limite de threads -->
    <div id="max-threads-control">
        <label for="max-threads">🛡️ Limite max de threads:</label>
        <input type="number" id="max-threads" value="100" min="1" max="1000" style="width: 80px;">
        <div class="warning-text">
            ⚠️ Attention: La commande 'f' peut créer des explosions de threads (ex: "+[f+]")
        </div>
    </div>
    
    <!-- Compteur d'étapes global -->
    <div id="step-counter" class="step-counter" style="display: none;">
        Étape: <span id="step-number">0</span>
    </div>

    <hr>
    
    <!-- Section d'information des threads -->
    <div id="thread-info">
        <strong>🔗 Thread Principal (T0)</strong> - Aucun fork détecté
    </div>
    
    <!-- Vue multi-thread (masquée par défaut) -->
    <div id="multi-thread-view" style="display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">🔀 État de Tous les Threads Actifs</h3>
            <button id="toggle-thread-details" style="padding: 5px 10px; font-size: 12px;">
                👁️ Vue Détaillée
            </button>
        </div>
        <div id="threads-container">
            <!-- Les threads s'afficheront ici dynamiquement -->
        </div>
    </div>
    
    <!-- Historique d'exécution -->
    <div id="execution-log" style="margin-top: 20px;">
        <!-- L'historique d'exécution s'affichera ici -->
    </div>
    
    <h2>Données d'Entrée (Input)</h2>
    <textarea id="bf-input" rows="3" cols="80" placeholder="Entrez les données lues par la commande ',' (virgule) ici. Par exemple: 'Hello'"></textarea>

    <h2>Sortie (Output)</h2>
    <pre id="output-view">En attente d'exécution...</pre>

    <hr>

    <h2>État de l'Interpréteur</h2>
    <p>
        Pointeur d'Instruction (IP): <span id="ip-view">0</span>
        &nbsp;|&nbsp;
        Pointeur de Cellule (PTR): <span id="ptr-view">0</span>
    </p>

    <h3>Code en cours d'exécution</h3>
    <pre id="code-view"></pre>

    <h3>Mémoire (Cellules autour du PTR)</h3>
    <div id="memory-view"></div>

    <script src="BrainfuckInterpreter.js"></script> 

    <script>
        let interpreter = null;

        // Références DOM
        const codeInput = document.getElementById('bf-code');
        const inputData = document.getElementById('bf-input');
        const outputView = document.getElementById('output-view');
        const ipView = document.getElementById('ip-view');
        const ptrView = document.getElementById('ptr-view');
        const memoryView = document.getElementById('memory-view');
        const codeView = document.getElementById('code-view');
        const codeHighlight = document.getElementById('code-highlight');
        const runAllBtn = document.getElementById('run-all');
        const stepBtn = document.getElementById('step-btn');
        const stepSingleBtn = document.getElementById('step-single-btn');
        const resetBtn = document.getElementById('reset-btn');

        const BF_TOKEN_CLASSES = {
            '>': 'bf-move-right',
            '<': 'bf-move-left',
            '+': 'bf-increment',
            '-': 'bf-decrement',
            '.': 'bf-output',
            ',': 'bf-input',
            '[': 'bf-loop-start',
            ']': 'bf-loop-end',
            'f': 'bf-fork'
        };

        function escapeHtml(text) {
            return text.replace(/[&<>"']/g, (char) => {
                switch (char) {
                    case '&': return '&amp;';
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '"': return '&quot;';
                    case "'": return '&#39;';
                    default: return char;
                }
            });
        }

        function buildHighlightedHtml(source, activeIndex = null) {
            if (!source) return '';
            let html = '';
            for (let i = 0; i < source.length; i++) {
                const char = source[i];
                if (char === '\n') {
                    html += '\n';
                    continue;
                }
                const classes = ['bf-token'];
                const tokenClass = BF_TOKEN_CLASSES[char] || 'bf-comment';
                classes.push(tokenClass);
                if (activeIndex !== null && i === activeIndex) {
                    classes.push('bf-active');
                }
                html += `<span class="${classes.join(' ')}">${escapeHtml(char)}</span>`;
            }
            return html;
        }

        function renderEditorHighlight(activeOriginalIndex = null) {
            codeHighlight.innerHTML = buildHighlightedHtml(codeInput.value, activeOriginalIndex);
            syncHighlightScroll();
        }

        function syncHighlightScroll() {
            codeHighlight.style.transform = `translate(${-codeInput.scrollLeft}px, ${-codeInput.scrollTop}px)`;
            // La transformation est plus fluide si elle est dans une frame d'animation
            requestAnimationFrame(() => {
                codeHighlight.style.transform = `translate(${-codeInput.scrollLeft}px, ${-codeInput.scrollTop}px)`;
            });
        }

        function setupMemoryScrollbar(wrapper) {
            if (!wrapper) return;

            const scrollContainer = wrapper.querySelector('.memory-scroll');
            const slider = wrapper.querySelector('.memory-scroll-slider');

            if (!scrollContainer || !slider) return;

            const updateSlider = () => {
                const overflow = scrollContainer.scrollWidth - scrollContainer.clientWidth;
                if (overflow > 0.5) {
                    slider.style.display = 'block';
                    slider.max = overflow;
                    slider.value = Math.min(scrollContainer.scrollLeft, overflow);
                } else {
                    slider.style.display = 'none';
                    slider.value = 0;
                    scrollContainer.scrollLeft = 0;
                }
            };

            slider.addEventListener('input', () => {
                scrollContainer.scrollLeft = Number(slider.value);
            });

            scrollContainer.addEventListener('scroll', () => {
                slider.value = scrollContainer.scrollLeft;
            });

            requestAnimationFrame(updateSlider);
        }

        codeInput.addEventListener('input', () => {
            renderEditorHighlight();
        });

        codeInput.addEventListener('scroll', () => {
            syncHighlightScroll();
        });
        
        window.addEventListener('resize', () => {
            syncHighlightScroll();
            if (interpreter) {
                updateUI();
            }
        });

        // Première coloration au chargement du script
        renderEditorHighlight();
        
        /**
         * Initialise ou réinitialise l'interpréteur avec le code et les données d'entrée.
         */
        function initializeInterpreter() {
            try {
                // Réinitialiser le gestionnaire de threads
                BrainfuckInterpreter.resetThreadManager();
                
                // Passage du code et des données d'entrée
                interpreter = new BrainfuckInterpreter(codeInput.value, inputData.value); 
                
                // Debug initial
                BrainfuckInterpreter.debugThreadManager();
                
                updateUI();
                runAllBtn.disabled = false;
                stepBtn.disabled = false;
                outputView.textContent = "Programme réinitialisé.";
            } catch (error) {
                alert("Erreur de syntaxe Brainfuck: " + error.message);
                interpreter = null;
            }
        }

        /**
         * Formate la valeur d'une cellule mémoire pour l'affichage.
         * Si la valeur correspond à un caractère ASCII imprimable, l'affiche.
         * @param {number} value La valeur numérique de la cellule.
         * @returns {string} La valeur formatée en HTML.
         */
        function formatMemoryCell(value) {
            const hexValue = '0x' + value.toString(16).toUpperCase().padStart(2, '0');

            // Les caractères imprimables ASCII sont généralement entre 32 (espace) et 126 (~)
            if (value >= 32 && value <= 126) {
                const char = escapeHtml(String.fromCharCode(value));
                return `${hexValue} <span style="color: #aaa; font-weight: bold;">'<span style="color: #0b7dda;">${char}</span>'</span>`;
            }
            // Pour les autres valeurs (non imprimables, null, etc.), on affiche juste le nombre.
            return hexValue;
        }

        /**
         * Génère les logs d'exécution des threads
         */
        function generateThreadExecutionLog() {
            const logElement = document.getElementById('execution-log');
            if (!logElement) return;
            
            let html = '<h4>📊 Historique d\'exécution</h4>';
            
            if (executionHistory.size === 0) {
                html += '<p style="color: #666; font-style: italic;">Aucune exécution pour le moment</p>';
            } else {
                html += '<div class="execution-stats">';
                
                // Statistiques globales
                const totalSteps = Array.from(executionHistory.values()).reduce((sum, steps) => sum + steps, 0);
                html += `<div class="stat-item">
                    <span class="stat-label">Total d'étapes:</span>
                    <span class="stat-value">${totalSteps}</span>
                </div>`;
                
                html += `<div class="stat-item">
                    <span class="stat-label">Threads actifs:</span>
                    <span class="stat-value">${executionHistory.size}</span>
                </div>`;
                
                html += '</div>';
                
                // Détails par thread
                html += '<div class="thread-logs">';
                for (const [threadId, steps] of executionHistory) {
                    const percentage = totalSteps > 0 ? ((steps / totalSteps) * 100).toFixed(1) : 0;
                    html += `
                        <div class="thread-log-item">
                            <div class="thread-log-header">
                                <span class="thread-id">Thread T${threadId}</span>
                                <span class="thread-steps">${steps} étapes (${percentage}%)</span>
                            </div>
                            <div class="thread-progress-bar">
                                <div class="thread-progress-fill" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    `;
                }
                html += '</div>';
            }
            
            logElement.innerHTML = html;
        }

        /**
         * Met à jour tous les éléments de l'interface utilisateur.
         */
        function updateUI() {
            if (!interpreter) return;

            const state = interpreter.getState();

            // 1. Mise à jour des compteurs et sortie
            outputView.textContent = state.output;
            ipView.textContent = state.ip;
            ptrView.textContent = state.ptr;

            // 2. Visualisation du code et du Pointeur d'Instruction (IP)
            
            const activeInstructionIndex = state.code.length === 0
                ? null
                : (state.ip < state.code.length ? state.ip : state.code.length - 1);
            const activeOriginalIndex = (!state.codeMap || state.codeMap.length === 0)
                ? null
                : (state.ip < state.codeMap.length ? state.codeMap[state.ip] : state.codeMap[state.codeMap.length - 1]);

            codeView.innerHTML = buildHighlightedHtml(state.code, activeInstructionIndex);
            renderEditorHighlight(activeOriginalIndex);


            // 3. Visualisation de la mémoire et du Pointeur de Cellule (PTR)
            let memDisplay = '<table>';
            const windowRadius = 7;
            const memoryLength = state.memoryFull.length;
            const start = Math.max(0, state.ptr - windowRadius);
            const end = Math.min(state.ptr + windowRadius + 1, memoryLength);

            // Ligne 1: Index (PTR)
            memDisplay += '<tr class="header-row">';
            if (start > 0) {
                memDisplay += '<td class="ellipsis-cell">…</td>';
            }
            for (let i = start; i < end; i++) {
                memDisplay += `<td>${i}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td class="ellipsis-cell">…</td>';
            }
            memDisplay += '</tr>';

            // Ligne 2: Valeurs (Contenu de la cellule)
            memDisplay += '<tr>';
            if (start > 0) {
                memDisplay += '<td class="ellipsis-cell">…</td>';
            }
            for (let i = start; i < end; i++) {
                const cellClass = i === state.ptr ? 'active-cell' : '';
                const cellContent = formatMemoryCell(state.memoryFull[i]);
                memDisplay += `<td class="${cellClass}">${cellContent}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td class="ellipsis-cell">…</td>';
            }
            memDisplay += '</tr>';
            memDisplay += '</table>';

            memoryView.innerHTML = `
                <div class="memory-scroll-wrapper">
                    <div class="memory-scroll" role="region" aria-label="Fenêtre mémoire défilable">${memDisplay}</div>
                    <input type="range" class="memory-scroll-slider" min="0" value="0" step="1" aria-label="Défilement horizontal de la mémoire">
                </div>
            `;

            const memoryWrapper = memoryView.querySelector('.memory-scroll-wrapper');
            setupMemoryScrollbar(memoryWrapper);

            // Centrer automatiquement la vue mémoire sur la cellule active
            const activeCellElement = memoryWrapper.querySelector('.active-cell');
            const scrollContainer = memoryWrapper.querySelector('.memory-scroll');
            if (activeCellElement && scrollContainer) {
                const containerWidth = scrollContainer.offsetWidth;
                const cellLeft = activeCellElement.offsetLeft;
                const cellWidth = activeCellElement.offsetWidth;
                // Calcule la position de défilement pour centrer la cellule
                const scrollTarget = cellLeft - (containerWidth / 2) + (cellWidth / 2);
                scrollContainer.scrollLeft = scrollTarget;
            }

            // 4. Mise à jour des informations de threading
            updateThreadInfo(state);
            
            // Nettoyer les threads terminés périodiquement
            if (state.totalThreads > 1) {
                const cleaned = BrainfuckInterpreter.cleanupHaltedThreads();
                if (cleaned > 0) {
                    console.log(`🧹 Nettoyage: ${cleaned} threads terminés supprimés`);
                }
            }
            
            // 5. Afficher la vue multi-thread si nécessaire
            if (state.totalThreads > 1) {
                updateMultiThreadView();
                document.getElementById('multi-thread-view').style.display = 'block';
                
                // Afficher le bouton Step Single en mode multi-thread
                stepSingleBtn.style.display = 'inline-block';
                stepBtn.textContent = '👣 Step (Tous Threads)';
            } else {
                document.getElementById('multi-thread-view').style.display = 'none';
                
                // Masquer le bouton Step Single en mode single-thread
                stepSingleBtn.style.display = 'none';
                stepBtn.textContent = '👣 Exécuter Pas à Pas';
            }

            // 5.5. Générer les logs d'exécution
            generateThreadExecutionLog();

            // 6. Gestion de la fin du programme
            if (state.halted) {
                runAllBtn.disabled = true;
                stepBtn.disabled = true;
                if (!outputView.textContent.includes("terminé")) {
                    outputView.textContent += "\n\n--- Programme terminé ---";
                }
            }
        }

        // Nouvelle fonction pour les informations de thread
        function updateThreadInfo(state) {
            const threadInfo = document.getElementById('thread-info');
            let infoHTML = `<strong>🔗 Thread T${state.threadId}</strong>`;
            
            if (state.parentId !== null) {
                infoHTML += ` (Enfant de T${state.parentId})`;
            } else {
                infoHTML += ` (Principal)`;
            }
            
            // Calculer les threads réels
            const manager = BrainfuckInterpreter.threadManager;
            let activeCount = 0;
            let totalCount = 0;
            if (manager) {
                for (const [threadId, thread] of manager.threads) {
                    totalCount++;
                    if (!thread.halted) {
                        activeCount++;
                    }
                }
            } else {
                activeCount = totalCount = 1;
            }
            
            infoHTML += `<br><strong>Threads:</strong> ${activeCount} actifs`;
            if (totalCount > activeCount) {
                infoHTML += ` (${totalCount - activeCount} terminés)`;
            }
            
            if (state.children.length > 0) {
                infoHTML += `<br><strong>Enfants Créés:</strong> [${state.children.map(id => `T${id}`).join(', ')}]`;
            }
            
            if (state.isForked) {
                infoHTML += `<br><span style="color: #ff6b35;">🔀 Ce thread a été créé par fork</span>`;
            }
            
            threadInfo.innerHTML = infoHTML;
        }

        // Nouvelle fonction pour la vue multi-thread
        function updateMultiThreadView() {
            const allStates = BrainfuckInterpreter.getAllThreadStates();
            const container = document.getElementById('threads-container');
            
            container.innerHTML = '';
            
            allStates.forEach((state, index) => {
                const threadDiv = document.createElement('div');
                const currentThreadId = interpreter ? interpreter.getState().threadId : 0;
                const isCurrentThread = state.threadId === currentThreadId;
                
                let className = 'thread-state ';
                if (isCurrentThread) {
                    className += 'current ';
                } else if (state.halted) {
                    className += 'halted ';
                } else {
                    className += 'active ';
                }
                threadDiv.className = className.trim();
                threadDiv.style.position = 'relative';
                
                // Calculer le progrès du thread (pourcentage d'instructions exécutées)
                const progress = state.code.length > 0 ? (state.ip / state.code.length) * 100 : 0;
                
                // En-tête du thread avec indicateur d'exécution
                const headerHTML = `
                    <div class="thread-header">
                        <span>🔗 Thread T${state.threadId} ${state.parentId !== null ? `(Parent: T${state.parentId})` : '(Principal)'} ${isCurrentThread ? '👑 Actuel' : ''}</span>
                        <span>${state.halted ? '🛑 Arrêté' : '▶️ Actif'}</span>
                    </div>
                    <div class="thread-progress-bar">
                        <div class="thread-progress-fill" style="width: ${Math.min(progress, 100)}%"></div>
                    </div>
                `;
                
                // Informations de base avec chronologie
                const steps = executionHistory.get(state.threadId) || 0;
                const detailsHTML = `
                    <div class="thread-details">
                        <strong>PTR:</strong> ${state.ptr} | 
                        <strong>IP:</strong> ${state.ip}/${state.code.length} | 
                        <strong>Cellule:</strong> ${state.memoryFull[state.ptr] || 0} | 
                        <strong>Étapes:</strong> ${steps}<br>
                        <strong>Instruction:</strong> "${state.currentInstruction || 'FIN'}" | 
                        <strong>Forks:</strong> ${state.forkCount || 0}/${state.maxForksPerThread || 2} | 
                        <strong>Sortie:</strong> "${escapeHtml(state.output.slice(-20))}${state.output.length > 20 ? '...' : ''}"<br>
                        ${state.children.length > 0 ? `<strong>Enfants:</strong> [${state.children.map(id => `T${id}`).join(', ')}]` : ''}
                        <div class="thread-timeline">
                            📊 Progrès: ${progress.toFixed(1)}% | 
                            ⏱️ Dernière activité: Étape ${globalStepCounter}
                        </div>
                    </div>
                `;
                
                // Contenu selon le mode d'affichage
                let contentHTML = headerHTML + detailsHTML;
                
                if (showDetailedThreadView) {
                    // Visualisation de la mémoire (fenêtre autour du PTR)
                    const memoryHTML = generateThreadMemoryView(state);
                    
                    // Code en cours d'exécution avec mise en évidence
                    const codeHTML = generateThreadCodeView(state);
                    
                    // Log d'exécution récent
                    const logHTML = generateThreadExecutionLog(state.threadId);
                    
                    contentHTML += memoryHTML + codeHTML + logHTML;
                }
                
                threadDiv.innerHTML = contentHTML;
                container.appendChild(threadDiv);
                
                // Ajouter effet visuel lors de l'exécution
                if (!state.halted && Math.random() < 0.3) { // Animation occasionnelle
                    setTimeout(() => {
                        const indicator = document.createElement('div');
                        indicator.className = 'thread-execution-indicator executing';
                        threadDiv.appendChild(indicator);
                        setTimeout(() => indicator.remove(), 500);
                    }, index * 100);
                }
            });
        }

        // Génère un log d'exécution pour un thread
        function generateThreadExecutionLog(threadId) {
            const history = executionHistory.get(threadId) || 0;
            const logs = [
                `Étape ${Math.max(0, globalStepCounter - 2)}: Instruction exécutée`,
                `Étape ${Math.max(0, globalStepCounter - 1)}: État mis à jour`,
                `Étape ${globalStepCounter}: État actuel`
            ];
            
            return `
                <div class="execution-log">
                    <strong>📝 Log d'exécution:</strong><br>
                    ${logs.slice(-3).map(log => `• ${log}`).join('<br>')}
                </div>
            `;
        }

        // Génère la vue mémoire pour un thread
        function generateThreadMemoryView(state) {
            const windowRadius = 5; // Fenêtre plus petite pour économiser l'espace
            const memoryLength = state.memoryFull.length;
            const start = Math.max(0, state.ptr - windowRadius);
            const end = Math.min(state.ptr + windowRadius + 1, memoryLength);

            let memDisplay = '<div class="thread-memory"><strong>Mémoire:</strong><div class="thread-memory-scroll"><table>';
            
            // Ligne 1: Index (PTR)
            memDisplay += '<tr class="header-row">';
            if (start > 0) {
                memDisplay += '<td>…</td>';
            }
            for (let i = start; i < end; i++) {
                memDisplay += `<td>${i}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td>…</td>';
            }
            memDisplay += '</tr>';

            // Ligne 2: Valeurs
            memDisplay += '<tr>';
            if (start > 0) {
                memDisplay += '<td>…</td>';
            }
            for (let i = start; i < end; i++) {
                const cellClass = i === state.ptr ? 'active-cell' : '';
                const value = state.memoryFull[i];
                const hexValue = '0x' + value.toString(16).toUpperCase().padStart(2, '0');
                let cellContent = hexValue;
                
                // Ajouter le caractère ASCII si imprimable
                if (value >= 32 && value <= 126) {
                    const char = escapeHtml(String.fromCharCode(value));
                    cellContent += `<br>'${char}'`;
                }
                
                memDisplay += `<td class="${cellClass}">${cellContent}</td>`;
            }
            if (end < memoryLength) {
                memDisplay += '<td>…</td>';
            }
            memDisplay += '</tr>';
            memDisplay += '</table></div></div>';
            
            return memDisplay;
        }

        // Génère la vue code pour un thread
        function generateThreadCodeView(state) {
            if (!state.code || state.code.length === 0) {
                return '<div class="thread-code"><em>Aucun code</em></div>';
            }
            
            // Afficher une fenêtre autour de l'IP actuel
            const windowRadius = 10;
            const start = Math.max(0, state.ip - windowRadius);
            const end = Math.min(state.ip + windowRadius + 1, state.code.length);
            
            let codeDisplay = '<div class="thread-code"><strong>Code (IP=' + state.ip + '):</strong><br>';
            
            if (start > 0) {
                codeDisplay += '…';
            }
            
            for (let i = start; i < end; i++) {
                const char = state.code[i];
                if (i === state.ip) {
                    // Instruction actuelle en surbrillance
                    codeDisplay += `<span style="background: #ff9900; color: white; padding: 1px 2px; border-radius: 2px;">${escapeHtml(char)}</span>`;
                } else {
                    // Coloration normale
                    const tokenClass = BF_TOKEN_CLASSES[char] || 'bf-comment';
                    codeDisplay += `<span class="${tokenClass}">${escapeHtml(char)}</span>`;
                }
            }
            
            if (end < state.code.length) {
                codeDisplay += '…';
            }
            
            codeDisplay += '</div>';
            return codeDisplay;
        }

        // --- Gestionnaires d'événements ---

        runAllBtn.addEventListener('click', () => {
            // Réinitialiser s'il n'y a pas d'interpréteur ou si l'exécution précédente est terminée
            if (!interpreter || interpreter.getState().halted) initializeInterpreter();
            if (interpreter) {
                try {
                    const state = interpreter.getState();
                    
                    if (state.totalThreads > 1) {
                        // Exécution multi-thread
                        console.log('🚀 Démarrage exécution multi-thread...');
                        const results = BrainfuckInterpreter.runAllThreads();
                        console.log('✅ Exécution terminée. Résultats:', results);
                        
                        // Afficher un résumé
                        const summary = results.map(r => 
                            `T${r.threadId}: "${r.output}"`
                        ).join('\n');
                        alert(`Exécution multi-thread terminée!\n\nRésultats:\n${summary}`);
                    } else {
                        // Exécution single-thread classique
                        interpreter.runAll();
                        console.log('✅ Exécution single-thread terminée');
                    }
                    
                    updateUI();
                } catch (error) {
                    alert(`❌ Erreur d'exécution: ${error.message}`);
                    console.error(error);
                }
            }
        });

        stepBtn.addEventListener('click', () => {
            if (!interpreter || interpreter.getState().halted) initializeInterpreter(); 
            if (interpreter) {
                try {
                    const state = interpreter.getState();
                    
                    // Incrémenter le compteur global
                    globalStepCounter++;
                    const stepNumberEl = document.getElementById('step-number');
                    if (stepNumberEl) stepNumberEl.textContent = globalStepCounter;
                    
                    const stepCounterEl = document.getElementById('step-counter');
                    if (stepCounterEl) stepCounterEl.style.display = 'block';
                    
                    if (state.totalThreads > 1) {
                        // Mode multi-thread: exécuter une étape pour chaque thread actif
                        const manager = BrainfuckInterpreter.threadManager;
                        let anyProgress = false;
                        const threadsToRemove = [];
                        
                        for (const [threadId, thread] of manager.threads) {
                            if (!thread.halted) {
                                // Incrémenter l'historique du thread
                                executionHistory.set(threadId, (executionHistory.get(threadId) || 0) + 1);
                                
                                const continued = thread.step();
                                if (continued) {
                                    anyProgress = true;
                                    
                                    // Effet visuel d'exécution
                                    console.log(`⚡ T${threadId}: ${thread.code[thread.ip - 1] || 'N/A'} (IP: ${thread.ip - 1} → ${thread.ip})`);
                                } else {
                                    // Thread terminé - pas besoin de manipulation manuelle
                                    console.log(`🛑 Thread T${threadId} terminé`);
                                }
                            }
                        }
                        
                        // Laisser le nettoyage automatique se faire
                        // (suppression du nettoyage manuel conflictuel)
                        
                        // Vérifier si tous les threads sont terminés
                        let activeCount = 0;
                        for (const [threadId, thread] of manager.threads) {
                            if (!thread.halted) activeCount++;
                        }
                        
                        if (activeCount === 0) {
                            console.log('🎯 Tous les threads sont terminés');
                            const stepCounterEl = document.getElementById('step-counter');
                            if (stepCounterEl) stepCounterEl.style.display = 'none';
                        }
                    } else {
                        // Mode single-thread classique
                        const threadId = interpreter.threadId;
                        executionHistory.set(threadId, (executionHistory.get(threadId) || 0) + 1);
                        
                        interpreter.step();
                        console.log(`⚡ T${threadId}: ${interpreter.code[interpreter.ip - 1] || 'N/A'} (IP: ${interpreter.ip - 1} → ${interpreter.ip})`);
                    }
                    
                    // Forcer le nettoyage des threads terminés après chaque step
                    console.log('🧹 Nettoyage forcé après step...');
                    BrainfuckInterpreter.cleanupHaltedThreads();
                    
                    updateUI();
                } catch (error) {
                    alert(`❌ Erreur d'exécution step: ${error.message}`);
                    console.error(error);
                }
            }
        });

        stepSingleBtn.addEventListener('click', () => {
            if (!interpreter) return;
            
            try {
                // Exécuter une étape seulement pour le thread principal (ou actuel)
                const continued = interpreter.step();
                if (!continued) {
                    console.log(`🛑 Thread T${interpreter.threadId} terminé`);
                }
                updateUI();
            } catch (error) {
                alert(`❌ Erreur d'exécution step single: ${error.message}`);
                console.error(error);
            }
        });

        resetBtn.addEventListener('click', () => {
            // Réinitialisation complète
            BrainfuckInterpreter.resetThreadManager();
            
            // Reset des compteurs
            globalStepCounter = 0;
            executionHistory.clear();
            
            // Reset sécurisé des éléments DOM
            const stepNumberEl = document.getElementById('step-number');
            if (stepNumberEl) stepNumberEl.textContent = '0';
            
            const stepCounterEl = document.getElementById('step-counter');
            if (stepCounterEl) stepCounterEl.style.display = 'none';
            
            // Nettoyer l'interface
            const outputEl = document.querySelector('#output pre');
            if (outputEl) outputEl.textContent = '';
            
            const memoryViewEl = document.getElementById('memory-view');
            if (memoryViewEl) memoryViewEl.innerHTML = '';
            
            const executionLogEl = document.getElementById('execution-log');
            if (executionLogEl) executionLogEl.innerHTML = '';
            
            console.clear();
            console.log('🔄 Interpréteur réinitialisé');
            
            initializeInterpreter();
        });

        // Gestionnaire pour la limite de threads
        document.getElementById('max-threads').addEventListener('change', (e) => {
            const newLimit = parseInt(e.target.value);
            if (newLimit > 0) {
                BrainfuckInterpreter.setMaxThreads(newLimit);
                console.log(`Limite de threads mise à jour: ${newLimit}`);
            }
        });

        // Variable pour contrôler la vue détaillée des threads
        let showDetailedThreadView = true;
        let globalStepCounter = 0;
        let executionHistory = new Map(); // Historique d'exécution par thread
        
        // Gestionnaire pour le bouton de bascule de vue
        document.getElementById('toggle-thread-details').addEventListener('click', () => {
            showDetailedThreadView = !showDetailedThreadView;
            const button = document.getElementById('toggle-thread-details');
            button.textContent = showDetailedThreadView ? '👁️ Vue Compacte' : '👁️ Vue Détaillée';
            
            // Mettre à jour l'affichage immédiatement
            if (interpreter && interpreter.getState().totalThreads > 1) {
                updateMultiThreadView();
            }
        });

        // Initialisation après le chargement complet
        window.addEventListener('load', () => {
            if (typeof BrainfuckInterpreter === 'undefined') {
                alert("Erreur: Le fichier 'BrainfuckInterpreter.js' n'a pas été trouvé ou chargé correctement. Vérifiez le chemin.");
            } else {
                // Initialiser le bouton de vue
                const toggleButton = document.getElementById('toggle-thread-details');
                toggleButton.textContent = showDetailedThreadView ? '👁️ Vue Compacte' : '👁️ Vue Détaillée';
                
                initializeInterpreter();
            }
        });

    </script>
</body>
</html>
